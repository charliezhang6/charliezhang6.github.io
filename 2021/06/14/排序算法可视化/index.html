<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>排序算法可视化 | 执酒天涯的小站</title><meta name="keywords" content="可视化"><meta name="author" content="执酒天涯"><meta name="copyright" content="执酒天涯"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="C大程大作业">
<meta property="og:type" content="article">
<meta property="og:title" content="排序算法可视化">
<meta property="og:url" content="http://charliezhang6.github.io/2021/06/14/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%8F%AF%E8%A7%86%E5%8C%96/index.html">
<meta property="og:site_name" content="执酒天涯的小站">
<meta property="og:description" content="C大程大作业">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://charliezhang6.github.io/img/visual-sort.png">
<meta property="article:published_time" content="2021-06-14T09:35:08.000Z">
<meta property="article:modified_time" content="2021-06-14T09:53:14.888Z">
<meta property="article:author" content="执酒天涯">
<meta property="article:tag" content="可视化">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://charliezhang6.github.io/img/visual-sort.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://charliezhang6.github.io/2021/06/14/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%8F%AF%E8%A7%86%E5%8C%96/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '排序算法可视化',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-06-14 17:53:14'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    })(window)</script><meta name="generator" content="Hexo 5.4.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src="/img/profile.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">12</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">7</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">5</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/me/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/visual-sort.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">执酒天涯的小站</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/me/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">排序算法可视化</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-06-14T09:35:08.000Z" title="发表于 2021-06-14 17:35:08">2021-06-14</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-06-14T09:53:14.888Z" title="更新于 2021-06-14 17:53:14">2021-06-14</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%A4%A7%E4%BD%9C%E4%B8%9A/">大作业</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="排序算法可视化"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1>visual-sort</h1>
<p>基于libgraphics和imgui的排序可视化算法，源代码可以看<a target="_blank" rel="noopener" href="https://github.com/charliezhang6/visual-sort">这里</a></p>
<h3 id="术语说明">术语说明</h3>
<p>sorter：指的是排序算法对象，sorter是一个结构体，其包含了一些字段和函数指针，不同的排序算法都要包含这个结构体，同时实现相关函数并给函数指针赋值，以实现某种多态性。本程序实现了五个具体的排序算法，冒泡排序 bubble sorter、快速排序 quick sorter、归并排序 merge sorter、插入排序 insertion sorter和选择排序 select sorter，同时可以方便添加其他排序算法，只要符合接口即可。具体见后文数据结构设计。</p>
<p>view：指的是视图，界面看见的部分称为 view，程序支持多个视图，通过函数 view_switch(view_name) 切换到不同的视图，类似与手机页面的切换。同时，view结构体也类似上述排序对象作为一个基类，本程序具体实现了 main-view 视图和 about-view 视图。前者是主要的排序界面，后者是程序的关于说明的页面。</p>
<p>menu: 指的是菜单栏或者菜单下拉框。</p>
<h2 id="总体框架设计">总体框架设计</h2>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1grhwgmxbtqj30o20foq5p.jpg" alt="图片 1"></p>
<h2 id="功能模块设计">功能模块设计</h2>
<p>为何实现高内聚低耦合，主要划分了视图模块、排序算法模块、通用工具模块和设置模块。</p>
<p>视图模块主要是由view.h、view.c、main-view.h、main-view.c、about-view.h和about-view.c构成。view.h和view.c分别是视图的基础结构和接口，以及视图操作的基本函数的实现；main-view.h和main-view.c是主视图（也就是排序页面）的实现；about-view.h和about-view.c是关于视图的实现，主要内容是作者名单。当然，后续可以继续添加新的视图，只需要实现view.h中的接口就可以。</p>
<p>排序模块有sorter.h、sorter.c、bubble-sorter.h、bubble-sorter.c、quick-sorter.h、quick-sorter.c、select-sorter.h、select-sorter.c、merge-sorter.h、merge-sorter.c、insertion-sorter.h、insertion-sorter.c文件构成，后续可以继续添加其他排序算法的可视化。和view.h一样，sorter.h、sorter.c是排序算法的基础结构和共同接口，bubble-sorter.c是冒泡排序的实现，quick-sorter.c是快速排序算法的实现，select-sorter.c是选择排序的实现，merge-sorter.c是归并排序的实现，insertion-sorter.c是插入排序的实现。</p>
<p>通用工具模块是 utility.h和utility.c实现，主要包括了一些通用的算法，比如最大值、最小值和随机数生成等算法的实现。</p>
<p>设置模块是 setting.h，主要定义了程序的一些基本属性，比如窗口大小等。</p>
<p>最后是主模块，也叫入口模块，只有一个文件main.c，里面是一些初始化工作，注册各个视图，通过定时器驱动页面的刷新等。</p>
<h2 id="数据结构设计">数据结构设计</h2>
<p>主要的数据结构有视图相关的<code> view_t</code>、<code>main_view_t</code>和<code>about_view_t</code>、排序算法相关的<code>sorter_t</code>、<code>bubble_sorter_t</code>、<code>quick_sorter_t</code>、<code>merge_sorter_t</code>、<code>insertion_sorter_t</code>和<code>select_sorter_t</code>。</p>
<p><code>view_t </code>结构体定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">view_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> <span class="keyword">const</span>* name;</span><br><span class="line">    <span class="keyword">void</span> (*display)(<span class="keyword">view_t</span> *me);</span><br><span class="line">    <span class="keyword">void</span> (*destroy)(<span class="keyword">view_t</span> *me);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其中<code>name</code>是视图名字，后续通过此名字来确定视图。<code>display</code>是函数指针，指向一个所谓的显示函数，用于把确定如何把此视图内容呈现到屏幕上，<code>destroy</code>是也是函数指针用于释放自定义视图的内存。具体如何工作起来的见下文对<code>main_view</code>和<code>about_view_t</code>的分析。</p>
<p><code>main_view_t</code>这是最为主要的视图，也就是排序页面的视图，定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">    DATASRC_RANDOM = <span class="number">1</span>,</span><br><span class="line">    DATASRC_ASCEND,</span><br><span class="line">    DATASRC_DESCEND,</span><br><span class="line">    DATASRC_LOADFILE,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span> SIZE_TEXT_MAX = <span class="number">64</span> &#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">main_view_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">view_t</span> base;</span><br><span class="line">    <span class="keyword">sorter_t</span> *sorter;</span><br><span class="line">    <span class="keyword">int</span> src_idx;</span><br><span class="line">    <span class="keyword">double</span> *nums;</span><br><span class="line"><span class="keyword">int</span> size;</span><br><span class="line"><span class="keyword">int</span> type;</span><br><span class="line">    <span class="keyword">char</span> size_text[SIZE_TEXT_MAX];</span><br><span class="line">&#125; <span class="keyword">main_view_t</span>;</span><br></pre></td></tr></table></figure>
<p>可以看见<code>main_view_t</code>结构体内嵌了<code>view_t</code>结构体，取名为<code>base</code>意味基类，这样可以让<code>main_view_t</code>具有<code>view_t</code>的性质；<code>sorter</code>的指针指向一个排序算法结构体，用于表明当前使用什么排序算法，具体来说可能是冒泡排序、快速排序、选择排序、归并排序、插入排序。<code>src_idx</code>是用于表明数据来源选择的是哪一个，取值为<code>DATASRC_RANDOM</code>表示随机生成，<code>DATASRC_ASCEND</code>表示随机生成升序数据，<code>DATASRC_DESCEND</code>表示随机生成降序数据，<code>DATASRC_LOADFILE</code>表示数据从文件加载，具体从当前目录下的“input.txt”读取数据；<code>nums</code>指针和<code>size</code>表明当前生成或加载的数据数组的地址和大小；<code>type</code>表示数据类型，可以取值为<code>SORTER_INT</code> 表明数据类型是整数，<code>SORTER_FLOAT</code>表示数据类型是浮点数，<code>SORTER_DOUBLE</code>表示数据类型是双精度浮点数；<code>size_text</code>是为了从界面上交互显示并输入<code>size</code>大小的缓冲区，最大长度为<code>SIZE_TEXT_MAX</code>长。这里常量使用 <code>enum</code>而不是通常的<code>#define</code>宏来定义，是为了方便编译后方便调试时具有符号，而不是简简单单的数字。</p>
<p><code>about_view_t</code>结构体很简单</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">about_view_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">view_t</span> base;</span><br><span class="line">&#125; <span class="keyword">about_view_t</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">和main_view_t结构体一样，不做介绍</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p><code>sorter_t</code>排序算法结构体，思想和<code>view_t</code>结构体思想一致</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">    NUMS_SIZE_MIN = <span class="number">10</span>,  <span class="comment">// 自动生成的数据最少个数</span></span><br><span class="line">    NUMS_SIZE_DFT = <span class="number">30</span>,  <span class="comment">// 默认生成的数据个数</span></span><br><span class="line">    NUMS_SIZE_MAX = <span class="number">1024</span>,<span class="comment">// 最多的数据个数</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">    SORTER_UNREADY = <span class="number">0</span>,</span><br><span class="line">    SORTER_READY,</span><br><span class="line">    SORTER_SORTING,</span><br><span class="line">    SORTER_PAUSED,</span><br><span class="line">    SORTER_SORTED,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">    SORTER_INT = <span class="number">0</span>,</span><br><span class="line">    SORTER_FLOAT,</span><br><span class="line">    SORTER_DOUBLE,</span><br><span class="line">    SORTER_TYPE_MAX,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sorter_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">double</span> *nums;</span><br><span class="line">    <span class="keyword">double</span> *nums_back;</span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line">    <span class="keyword">double</span> min, max;</span><br><span class="line">    <span class="keyword">int</span> type;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">double</span> speed;</span><br><span class="line">    <span class="keyword">int</span> frame_cnt;</span><br><span class="line">    <span class="keyword">int</span> state;</span><br><span class="line">    <span class="keyword">bool</span> ascend;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> (*next_step)(<span class="keyword">sorter_t</span> *me);</span><br><span class="line">    <span class="keyword">void</span> (*display)(<span class="keyword">sorter_t</span> *me, <span class="keyword">double</span> x, <span class="keyword">double</span> y, <span class="keyword">double</span> w, <span class="keyword">double</span> h);</span><br><span class="line">    <span class="keyword">void</span> (*restart)(<span class="keyword">sorter_t</span> *me);</span><br><span class="line">    <span class="keyword">void</span> (*destroy)(<span class="keyword">sorter_t</span> *me);</span><br><span class="line">    <span class="keyword">bool</span> (*save_state)(<span class="keyword">sorter_t</span> *me, <span class="keyword">char</span> <span class="keyword">const</span> *ofile);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>nums</code>和<code>size</code>都是用于记录排序的数据的信息的，<code>nums_back</code>是对未排序前的<code>nums</code>的数据的备份，用于实现重新排序的功能。正如注释提到的一样 <code>nums </code>指向的内存所有权不是<code>sorter_t</code>的而是外部的，需要外界释放内容，但是<code>nums_back</code>是此结构体分配的，所以需要自己释放。<code>min</code>和<code>max</code>分别记录数据中的最大值和最小值，用于后面绘图时使用。type表示被排序的数据类型取值为<code>SORTER_INT</code>、<code>SORTER_FLOAT</code>、<code>SORTER_DOUBLE</code>分别表示int类型，float类型和double类型的数据。</p>
<p><code>speed</code>记录可视化排序过程的快慢，每秒多少步。<code>frame_cnt</code>记录从上一步到现在界面刷新了多少帧（多少次画面）。<code>state</code>记录排序算法的状态，取值有<code>SORTER_UNREADY</code>，表示排序算法为准备好，也就是数据没有被提供；<code>SORTER_READY</code>表示排序算法准备好了，下一步可以进行排序；<code>SORTER_SORTING</code>表示算法正在排序过程中；<code>SORTER_PAUSED</code>表示排序算法被暂停，后续可以恢复继续排序；<code>SORTER_SORTED</code>表示排序过程结束，数据已经排好序了。<code>ascend</code>表示排序的顺序，升序还是降序，当<code>ascend</code>为真表示按照升序排序（也是默认排序方式），当<code>ascend</code>为假表示按照降序排序。</p>
<p>函数指针<code>next_step</code>用于记录子结构的实现下一步操作的函数的地址；<code>display</code>用于实现如何可视化排序的内部情况；<code>restart</code>用于重新操作结构体内部变量，实现重新排序的功能；<code>destroy</code>用于记录如何释放结构体内存；<code>save_state</code>用于存储当前状态到文件里。</p>
<p><code>bubble_sorter_t</code>结构体是<code>sorter_t</code>的子结构体，是对冒泡排序算法的具体实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">bubble_sorter_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">sorter_t</span> base;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> k;  <span class="comment">// 排序好了多少个元素</span></span><br><span class="line">    <span class="keyword">int</span> i;  <span class="comment">// 当前这一轮进行到哪个元素</span></span><br><span class="line">&#125; <span class="keyword">bubble_sorter_t</span>;</span><br></pre></td></tr></table></figure>
<p><code>base</code>是排序算法的基类，k和i变量的含义正如注释里写的一样。</p>
<p>快速排序是一个比较复杂的排序算法，所以其对应结构体也较为复杂：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span> STACK_MAX = <span class="number">1024</span> &#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">quick_sorter_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">sorter_t</span> base;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">stack</span>[STACK_MAX][<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">int</span> stack_size;</span><br><span class="line">    <span class="keyword">int</span> done_list[NUMS_SIZE_MAX];</span><br><span class="line">    <span class="keyword">int</span> done_size;</span><br><span class="line">    <span class="keyword">int</span> state;</span><br><span class="line">    <span class="keyword">int</span> lo, hi;</span><br><span class="line">    <span class="keyword">int</span> l, r;</span><br><span class="line">    <span class="keyword">int</span> pivot_idx;</span><br><span class="line">&#125; <span class="keyword">quick_sorter_t</span>;</span><br></pre></td></tr></table></figure>
<p>同样的<code>base</code>是基类结构体，二维数据<code>stack</code>用于记录递归的情况，最大递归深度<code>STACK_SIZE</code>为1024，<code>stack[i][0]</code>表示递归深度为i时左边界，<code>stack[i][1]</code>表示递归深度为i时右边界。<code>done_list</code>和<code>done_size</code>用于记录哪些下标的元素已经被排好序了，方便可视化时特别展示出来。<code>state</code>同样用于记录快速排序的内部状态。<code>lo</code>和<code>hi</code>记录当前轮快速排序正在处理的元素的左右边界下标分别是多少，<code>l</code>和<code>r</code>时记录元素划分时左边和右边的下标，<code>pivot_idx</code>记录枢纽元的下标是多少。</p>
<p><code>select_sorter_t</code>对应的是选择排序</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">select_sorter_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">sorter_t</span> base;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> k;  <span class="comment">// 排序好了多少个元素</span></span><br><span class="line"><span class="keyword">int</span> i;  <span class="comment">// 当前这一轮进行到哪个元素</span></span><br><span class="line"><span class="keyword">int</span> max;  <span class="comment">// 当前这一轮最值下标</span></span><br><span class="line">&#125; <span class="keyword">select_sorter_t</span>;</span><br></pre></td></tr></table></figure>
<p>比起冒泡排序多了一个<code>max</code>值用于标记当前这轮所确定的最值下标</p>
<p><code>merge_sorter_t</code>结构体对应的是归并排序，具体如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">merge_sorter_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">sorter_t</span> base;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> doing_size;   </span><br><span class="line"><span class="keyword">double</span> doing_list[NUMS_SIZE_MAX];   </span><br><span class="line"><span class="keyword">int</span> start,end,mid;  </span><br><span class="line"><span class="keyword">int</span> state;</span><br><span class="line"><span class="keyword">int</span> i,j,k;</span><br><span class="line">&#125; <span class="keyword">merge_sorter_t</span>;</span><br></pre></td></tr></table></figure>
<p>与上述结构相同<code>base</code>是基类结构体，<code>doing_size</code>记录正在排序的元素个数，<code>doing_list[]</code>用于记录正在排序的元素，<code>start</code>,<code>end</code>,<code>mid</code>用于标记正在排序部分的始末和中间下标，<code>state</code>用于记录归并排序的内部状态，<code>i</code>，<code>j</code>，<code>k</code>用于记录当前正在比较的元素下标。</p>
<p><code>insertion_sorter_t</code>结构体对应的是插入排序，具体如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">insertion_sorter_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">sorter_t</span> base;</span><br><span class="line">  <span class="keyword">int</span> k;</span><br><span class="line">  <span class="keyword">int</span> i;  </span><br><span class="line">  <span class="keyword">int</span> flag; </span><br><span class="line">  <span class="keyword">int</span> state;</span><br><span class="line"><span class="keyword">double</span> doing_list[NUMS_SIZE_MAX];</span><br><span class="line">&#125; <span class="keyword">insertion_sorter_t</span>;</span><br></pre></td></tr></table></figure>
<p>与上述结构相同<code>base</code>是基类结构体，<code>k</code>记录当前排序元素移动的位置，<code>i</code>记录当前排序元素的起始下标，<code>flag</code>记录绘制数据的状态，<code>state</code>用于记录插入排序的内部状态，<code>doing_list[]</code>用于记录正在排序的元素。</p>
<h3 id="多文件构成机制">多文件构成机制</h3>
<p>为了实现多文件编译，每个头文件都定义了<code>#ifndef FILENAME_H</code>__，<code>#define FILENAME_H__</code>和<code>#endif</code>宏，把正常内容包含其中以实现每次<code>#include</code>只被引入一次，以防止出现重复声明和定义。同时每个*.c文件都有对应的*.h文件，里面声明了可以从*.c中使用的外部函数的原型，如果是 <em>.c 文件中的私有函数（不希望外部可以使用的函数）加上 static 限制作用域为本</em>.c文件。如果是*.h头文件中定义的变量，通常都是希望是私有的所以有static修饰作用域为本文件以防止出现链接错误。对于内联函数比如<code>void swap(double *a, double \*b)</code>也是用<code>static</code>修饰，以防止出现链接时多次定义，本程序没有使用外部变量，所以不需要外部变量的链接问题。虽然在*.c文件中定义了外部变量，但是这些变量都是默认为本文件内使用，所以不会被其他文件所感知到。</p>
<h1>函数设计描述</h1>
<h3 id="main-c文件中函数的说明：">main.c文件中函数的说明：</h3>
<p><code>void Mian(void);</code></p>
<p>此函数主要完成初始化工作，包括调用 InitGraphic()以初始化graphics环境，调用 initGUI完成ImGUI库的初始化，调用 initialize() 函数完成本程序其他模块的初始化，注册destroy()函数到程序退出时候以释放资源，设置窗口标题为 Visual Sort，把ImGUI的uiGetChar()、uiGetKeyboard()、uiGetMouse()注册到graphic库中，以获得鼠标键盘等情况，同时注册一个定时器id为1的定时器。</p>
<p><code>  static void main_loop_timer_handler(int timeid);</code></p>
<p>函数首先调用DisplayClear()函数清屏，然后调用 view_display()函数显示当前活动的view页面到屏幕上。</p>
<p>timeid: 是此函数注册到定时器id</p>
<p><code>static void initialize(void);</code></p>
<p>创建并添加两个视图 main 和 about到视图管理模块中，并设置默认主题颜色为4号</p>
<p><code>static void destroy(void);</code></p>
<p>调用 view_destroy() 释放所有视图的内存</p>
<p>view.c文件中函数的说明：在这个文件中有三个文件内作用域的全局变量 view_t *views[VIEWS_MAX]、 int view_cnt和    view_t *active，第一个和第二个变量共同记录所有的视图，active指向当前活动的视图。</p>
<p><code>static void view_lookup_by_name(char const *name);</code></p>
<p>查找视图名字为name的视图的下标，没找到返回 VIEW_NOTFOUND (-1)。</p>
<p>name: 需要查找的视图的名字</p>
<p><code> int view_default(char const *name);</code></p>
<p>设置默认活动的视图，内部间接调用 view_switch(name) 实现，具体见下面分析。</p>
<p>name: 视图的名字</p>
<p><code> void view_display(void);</code></p>
<p>调用当前活动的视图的display()，在屏幕上显示视图的内容。</p>
<p><code> int view_switch(char const *name);</code></p>
<p>切换名为name的视图为活动视图，内部使用 view_lookup_by_name(name) 找到视图下标，然后修改 active = views[idx] 以便设置为活动视图。</p>
<p>name: 视图名字</p>
<p>返回值：VIEW_NOTFOUND 名为name的视图没有找到</p>
<p>​    VIEW_OK 切换成功</p>
<p><code> int view_add(view_t *view);</code></p>
<p>通过查找 views 是否有空余位置，然后把 view 添加到里面去。</p>
<p>view: 待添加的视图</p>
<p>返回值：VIEW_INVALID 视图 view 为空指针，不合法</p>
<p>​    VIEW_TOOMANY 添加的视图过多</p>
<p>​    VIEW_OK 添加视图成功</p>
<p><code>static void view_remove_by_idx(int idx);</code></p>
<p>移除下标为 idx 处的视图，并调用其注册的销毁函数，同时把 views[idx] 置为NULL</p>
<p>idx: 视图的下标</p>
<p><code>int view_remove(char const *name);</code></p>
<p>通过使用 view_lookup_by_name(name) 找到视图的索引 idx，然后使用 view_remove_by_idx(idx)删除这个视图。</p>
<p>name: 视图名字</p>
<p>返回值：VIEW_NOTFOUND 名为name视图没有找到</p>
<p>​    VIEW_OK 删除成功</p>
<p><code>void view_destroy(void);</code></p>
<p>销毁所有记录在views里的视图，并置view_cnt为0，active为NULL</p>
<h3 id="main-view-c中函数的说明：">main-view.c中函数的说明：</h3>
<p><code>view_t *main_view_create(char const *name);</code></p>
<p>创建名为 name 的 main_view_t 类型结构体，内部会为 main_view_t 分配空间并初始化，包括初始化基类 view_t，设置 view_t 结构体里的display和destroy函数指针为本文定义的display和 destroy函数。设置默认的排序算法为冒泡排序。</p>
<p>name: 视图名字</p>
<p>返回值：main_view_t 结构体内部成员基类 base 的地址，这个类型是 view_t 类型的</p>
<p><code>static void display(view_t *b);</code></p>
<p>显示视图，对于main_view_t 类型而言，首先调用 container_of从b计算出子类的地址赋值给me变量。然后分别调用menubar_display()、leftside_column_display()、drawLine()显示界面的菜单栏、左边控制部分界面和左右部分分界线。之后使用sorter_update(me-&gt;sorter)更新排序算法的内部，随后调用sorter-&gt;display()把排序可视化到屏幕。</p>
<p>b: 视图的基类，main_view_t内包含的base成员的地址</p>
<p><code>static void destroy(view_t *b);</code></p>
<p>释放生成的数据，释放sorter结构体，释放本结构所占的内存。</p>
<p>b: 视图的基类，main_view_t内包含的base成员的地址</p>
<p><code>static void leftside_column_display(main_view_t *me, double x, double y, double w, double h);</code></p>
<p>显示左侧控制按钮。内部调用了data_source_display()显示获取数据的控件，显示了选择算法的下拉菜单，排序顺序的按钮，控件排序速度的控件，排序状态、控制状态和保存状态的按钮。同时这些按钮根据排序状态的不同可能是不可以交互的，比如当数据没有准备好时，排序按钮不会显示，当排序进行过程中，选择数据源和排序算法的下拉菜单不可以交互，直到重新排序或者排序完成才可以重新交互。</p>
<p>me: main_view_t 类型的结构体地址</p>
<p>x, y, w, h: 在坐标(x,y)处显示，长宽分别是w, h英寸</p>
<p><code>static double data_source_display(main_view_t *me, double x, double y, double w, double h);</code></p>
<p>首先显示“Load Saved State”的按钮，如果点击此按钮就会尝试从“sorter-staet.bin”文件加载保存的排序状态，并加载。然后显示数据来源的下拉菜单，如果选择随机生成还会显示文本框提示数据数据量大小，如果时选择从文件中加载那么尝试自动加载名为“input.txt”的文件内的数据。</p>
<p>me: main_view_t 类型的结构体地址</p>
<p>x, y, w, h: 在坐标(x,y)处显示，长宽分别是w, h英寸</p>
<p>返回值：控件下边界的y坐标</p>
<p><code>static void control_buttons_display(main_view_t *me, double x, double y, double w, double h);</code></p>
<p>显示减速、加速、下一步和速度值的按钮。</p>
<p>me: main_view_t 类型的结构体地址</p>
<p>x, y, w, h: 在坐标(x,y)处显示，长宽分别是w, h英寸</p>
<p><code>static int double_less(void const *a, void const *b);</code></p>
<p>给qsort函数使用的回调函数，返回 a – b的值，用于按照从小到大排序</p>
<p>a：指向第一个数的地址</p>
<p>b：指向第二个数的地址</p>
<p>返回值：&lt;0：a &lt; b</p>
<p>​     0：a == b</p>
<p>​    &gt;0：a &gt; b</p>
<p><code>static int double_great(void const *a, void const *b);</code></p>
<p>同 int_less，只是此函数按照从大到小排序，等价于调用 int_less(b, a)</p>
<p><code>static bool generate_nums(main_view_t *me);</code></p>
<p>根据me-&gt;alg_idx决定生成什么类型的数据，如果时DATASRC_RANDOM则调用random_nums(0, 4*size, size)生成me中指定数据量为size的数据，如果为DATASRC_ASCEND或DATASRC_DESCEND再调用qsort()对数据排序；如果是DATASRC_LOADFILE，那么使用load_nums()从文件“input.txt”中加载数据，然后使用sorter_set_nums()给排序算法添加数据。</p>
<p>me: main_view_t类型的结构体指针</p>
<p>返回值：true：操作成功</p>
<p>​    false：操作失败</p>
<h3 id="about-view-c中函数的说明：">about-view.c中函数的说明：</h3>
<p><code>static void display(view_t *me);</code></p>
<p>和main-view.c中的display类似，显示关于视图到屏幕上，具体显示的内容为作者列表。</p>
<p>me: about_view_t结构体内base成员的地址</p>
<p><code> view_t *about_view_create(void);</code></p>
<p>和main_view_create类似，只是给destroy成员赋值为VIEW_DESTROY_DFT，表明不需要特殊的释放内存方式，使用view_t内部默认的释放内存方式即可。</p>
<p>返回值： about_view_t 结构体成员base的地址</p>
<h3 id="sorter-c中函数的说明：">sorter.c中函数的说明：</h3>
<p><code>void sorter_update(sorter_t *me);</code></p>
<p>如果当前排序状态不是SORTER_SORTING，直接返回。</p>
<p>让me-&gt;frame_cnt加一，如果frame_cnt乘以帧与帧之间间隔的时间大于等于1000除以速度时，调用me-&gt;next_step(me)更新到下一步。</p>
<p>me: 排序算法结构体指针</p>
<p><code>void sorter_speed_ctl(sorter_t *me, bool inc);</code></p>
<p>如果inc为真，增加速度最大值时SPEED_MAX(50)，如果inc为假，减少速度值，最小值为SPEED_MIN。</p>
<p>me: 排序算法结构体指针</p>
<p>inc: true增加速度，false减少速度</p>
<p><code>sorter_t *sorter_construct(sorter_t *me);</code></p>
<p>初始化me结构体的成员，包括设置速度为默认值SPEED_DFT、frame_cnt为0，状态为SORTER_UNREADY、排序按照升序排序等。</p>
<p>me: 排序算法结构体指针</p>
<p>返回值：me</p>
<p><code>sorter_t *sorter_load_from(sorter_t *me, FILE *istream);</code></p>
<p>从文件输入流istream中读取数据并解析校验通过后，给me结构体进行初始化。首先读取被排序的元素的个数size，然后依次读取已经被部分排序的素组和原始数据的数组，然后再读取速度speed、帧计数frame_cnt、状态state、升序与否ascend，之后计算出最大值和最小值给me初始化。整个过程成功返回me，失败返回空指针。</p>
<p>me: 排序算法结构体指针</p>
<p>istream: 包含有待待解析的数据的输入流</p>
<p>返回值：me：读取并初始化成功</p>
<p>NULL：读取或者初始化失败</p>
<p><code>void sorter_deconstruct(sorter_t *me);</code></p>
<p>释放me结构体中nums和nums_back的空间。</p>
<p><code>bool sorter_set_nums(sorter_t *me, double *nums, int size, int type);</code></p>
<p>为排序算法设置数据，包括数据量大小和数据类型，设置当前数据的备份，采取的是从nums复制数据到me-&gt;nums和me-&gt;nums_back，并求出最大值最小值。</p>
<p>me: 排序算法结构体</p>
<p>nums, size: 输入的数据</p>
<p>type: 输入数据的类型</p>
<p>返回值：true: 设置成功</p>
<p>​    false: 设置失败</p>
<p><code>void sorter_restart(sorter_t *me);</code></p>
<p>重置排序算法的状态，包括从nums_back复制数据到nums数组，frame_cnt设置为0，状态为SORTER_READY</p>
<p>me: 排序算法结构体指针</p>
<p><code> void sorter_display_unready(double x, double y, double w, double h);</code></p>
<p>在起点为x, y宽高分别是w, h的区域显示数据没有准备好的提示</p>
<p>x, y: 区域起始坐标，单位英寸</p>
<p>w, h: 区域宽高，单位英寸</p>
<p><code>bool sorter_save_state_at(sorter_t *me, FILE *ostream);</code></p>
<p>格式sorter_t类型的结构体me到输出流ostream中，此格式可以被sorter_load_from()函数解析用以还原此结构体。</p>
<p>me: 排序算法结构体</p>
<p>ostream: 输出流</p>
<p>返回值：true：格式化输出成功</p>
<p>​    false：格式化输出失败</p>
<h3 id="bubble-sorter-c中函数的说明：">bubble-sorter.c中函数的说明：</h3>
<p><code>static void next_step(sorter_t *b);</code></p>
<p>冒泡排序执行下一步操作。具体来说，当排序算法没有处于SORTER_SORTING或者SORTER_PAUSED状态时，直接返回。设置frame_cnt为0，根据冒泡排序过程比较nums[i]和nums[i+1]的大小，当nums[i]&gt;nums[i+1]和ascned同时为真（升序排序），或者同时为假时（降序排序）交换nums[i]和nums[i+1]。然后me-&gt;i加一，完成冒泡排序的一步。</p>
<p>b: 冒泡排序成员base的地址</p>
<p><code>static void display(sorter_t *b);</code></p>
<p>如果状态是SORTER_UNREADY时，调用sorter_display_unready()函数并返回。然后按照柱状图形式可视化当前排序的状态，对于已经排好序的数据绘制为深灰色Dark Gray，对于未排好序的数据绘制为浅灰色Light Gray，当前排序进行到的数据绘制为橘黄色Orange，同时如果数据量过多导致柱宽度小于0.05那么不绘制边框。</p>
<p>b: 冒泡排序成员base的地址</p>
<p><code>static void restart(sorter_t *b);</code></p>
<p>调用 sorter_restart(b)，然后设置i和k为0，以表示重新排序。</p>
<p>b: 冒泡排序成员base的地址</p>
<p><code>static void destroy(sorter_t *b);</code></p>
<p>释放内存，通过container_of计算出包含b的结构体起始地址然后调用free()释放内存。</p>
<p>b: 冒泡排序成员base的地址</p>
<p><code>static bool save_state(sorter_t *b, char const *ofile);</code></p>
<p>保存冒泡排序的状态到文件 ofile 里。具体来说，首先调用 sorter_save_state_at() 存储sorter_t结构体信息到文件里，然后存储i和k到文件里。</p>
<p>b: b: 冒泡排序成员base的地址</p>
<p>ofile: 输出到的文件名</p>
<p>返回值：true：存储成功，false：存储失败</p>
<p><code>sorter_t *bubble_sorter_create(void);</code></p>
<p>同main_view_create()类似，分配一个bubble_sort_t结构体，并初始化成员，然后返回成员base的地址</p>
<p>返回值：成员base的地址，类型是sorter_t</p>
<p><code>sorter_t *bubble_sorter_load(char const *state_file);</code></p>
<p>从文件 state_file 中读取、解析并初始化一个 bubble_sorter_t 的结构体，然后返回其结构体内部 base 成员的地址。冒泡排序文件格式，第一行是“!!bubble sort state file!!”，然后是 sorter_t 结构体保存到文件的数据，然后是bubble_sorter_t结构体中i和k的值。</p>
<p>state_file：状态文件</p>
<p>返回值：成员base的地址，类型是sorter_t</p>
<p>quick-sorter.c中函数的说明，quick-sorter中的这些函数名字和bubble-sorter中名字类似，功能也是一致的，只是实现细节和排序算法相关：</p>
<p><code>static void next_step(sorter_t *b);</code></p>
<p>由于快速排序的复杂性，这个函数是快速排序模块最为复杂的函数，相当于把递归的快速排序用非递归来实现，同时又把其成一步步运行的状态。函数内部定义了两个宏push和pop用于操作栈，整个排序过程分为了多个内部状态QUICK_INIT初始状态，处于这个状态只把0和size-1这个区间压入栈，然后进入 QUICK_SORT1，这个状态首先判断栈是不是为空，如果是那么排序完成，否则弹出元素，并进入状态QUICK_PIVOT，准备根据枢纽元划分区间，此状态选择区间最右边元素作为枢纽元设置me-&gt;pivot_idx为r，然后进入QUICK_PARTITION_LO状态，移动l指针一步，然后保持这个状态，直到多次调用next_step使得l和r交错或者nums[l]大于nums[pivot_idx]进入QUICK_PARTITION_HI以便移动h指针，类似减少h指针直到l和r交错或者nums[h]小于nums[pivot_idx]，然后进入状态QUICK_SWAP，如果l和r交错那么进入QUICK_PARTITION_END状态，否则交换nums[l]和nums[r]然后继续进入QUICK_PARTITION_LO状态进行划分；处于QUICK_PARTITION_END状态时，把枢纽元交换到nums[l]处，然后进入压入当前区间的状态QUICK_PUSH_SEGMENT，处于此状态添加枢纽元下标到done_list中，然后更具lo和pivot_idx以及pivot_idx和hi的关于决定是否把左半区间压入栈或者把右半区间压入栈，然后状态进入QUICK_SORT1开始继续处理。</p>
<p>b: 快速排序结构体成员base的地址</p>
<p><code>static void display(sorter_t *b);</code></p>
<p>和冒泡排序算法的display()类似，对排序好的数据绘制为深灰色，未排序好的数据为浅灰色，当前活动的数据为橘黄色，此外还增加了绘制枢纽元颜色为棕色Brown，绘制枢纽元高度的水平线，绘制当前活动区间的两条竖线，如果正在交互两个元素，这两个元素为红色以展示交换过程。</p>
<p>b: 快速排序结构体成员base的地址</p>
<p><code>static void restart(sorter_t *b);</code></p>
<p>重置快速排序过程，调用sorter_restart(b)然后重置stack_size为0，done_size 为0，pivot_idx 为-1，状态为QUICK_INIT状态。</p>
<p>b: 快速排序结构体成员base的地址</p>
<p><code>static void destroy(sorter_t *b);</code></p>
<p>和冒泡排序的destroy函数功能完全一样，只是释放内存。</p>
<p>b: 快速排序结构体成员base的地址</p>
<p><code>static bool save_state(sorter_t *b, char const *ofile);</code></p>
<p>保存快速排序算法的状态到文件ofile。类似于bubble-sorter.c中的save_state一样。第一行输出“!!quick sort state file!!”，然后调用sorter_save_state_at()保存成员变量base的状态，之后输出stack_size和栈的所有数据；输出done_size和done_list数组的值，输出状态state，lo, hi, l, r和pivot_idx的值。</p>
<p>b: 快速排序结构体成员base的地址</p>
<p>ofile: 存储状态的文件</p>
<p>返回值：true: 保存成功，false：保存失败</p>
<p><code>sorter_t *quick_sorter_create(void);</code></p>
<p>分配quick_sort_t类型结构体，并初始化。包括设置base成员的各个函数指针以及stack_size设置为0，done_size设置为0，pivot_idx为-1，状态为QUICK_INIT</p>
<p>返回值： 快速排序结构体成员base的地址，如果分配内存失败返回NULL</p>
<p><code>sorter_t *quick_sorter_load(char const *state_file);</code></p>
<p>从状态文件中读取数据并初始化快速排序结构体 quick_sorter_t。具体来说，首先读取第一行判断是不是为“!!quick sort state file!!”，成功的话继续使用 sorter_load_from()从文件流中继续读取数据并初始化base成员，之后继续读取stack_size和栈的数据，读取done_size和done_list数组的数据，读取状态state，读取lo, hi, l, r和pivot_idx的值。</p>
<p>state_file：状态文件名</p>
<p>返回值：初始化好的快速排序结构体内部base成员的地址；如果加载或初始化失败返回NULL</p>
<h3 id="select-sorter-c中函数的说明：">select-sorter.c中函数的说明：</h3>
<p><code>static void next_step(sorter_t *b);</code></p>
<p>选择排序执行下一步操作。具体来说，当排序算法没有处于SORTER_SORTING或者SORTER_PAUSED状态时，直接返回。设置frame_cnt为0。根据选择排序过程，比较nums[max]和nums[i]的大小，如果nums[max]小于nums[i]且排序方式为升序的话，则把i赋值给max。一轮过后交换max和i的值。</p>
<p>b: 选择排序成员base的地址</p>
<p><code>static void display(sorter_t *b);</code></p>
<p>如果状态是SORTER_UNREADY时，调用sorter_display_unready()函数并返回。然后按照柱状图形式可视化当前排序的状态，对于已经排好序的数据绘制为深灰色Dark Gray，对于未排好序的数据绘制为浅灰色Light Gray，当前排序进行到的数据绘制为橘黄色Orange，当前的最值数据绘制为红色Red,同时如果数据量过多导致柱宽度小于0.05那么不绘制边框。</p>
<p>b: 选择排序成员base的地址</p>
<p><code>static void restart(sorter_t *b);</code></p>
<p>调用 sorter_restart(b)，然后设置i和k为0，以表示重新排序。</p>
<p>b: 选择排序成员base的地址</p>
<p><code>static void destroy(sorter_t *b);</code></p>
<p>释放内存，通过container_of计算出包含b的结构体起始地址然后调用free()释放内存。</p>
<p>b: 选择排序成员base的地址</p>
<p><code>static bool save_state(sorter_t *b, char const *ofile);</code></p>
<p>保存选择排序的状态到文件 ofile 里。具体来说，首先调用 sorter_save_state_at() 存储sorter_t结构体信息到文件里，然后存储i、max和k到文件里。</p>
<p>b: b: 选择排序成员base的地址</p>
<p>ofile: 输出到的文件名</p>
<p>返回值：true：存储成功，false：存储失败</p>
<p><code>sorter_t *select_sorter_create(void);</code></p>
<p>同main_view_create()类似，分配一个select_sort_t结构体，并初始化成员，然后返回成员base的地址</p>
<p>返回值：成员base的地址，类型是sorter_t</p>
<p><code>sorter_t *select_sorter_load(char const *state_file);</code></p>
<p>从文件 state_file 中读取、解析并初始化一个 select_sorter_t 的结构体，然后返回其结构体内部 base 成员的地址。选择排序文件格式，第一行是“!!select sort state file!!”，然后是 sorter_t 结构体保存到文件的数据，然后是select_sorter_t结构体中i和k以及max的值。</p>
<p>state_file：状态文件</p>
<p>返回值：成员base的地址，类型是sorter_t</p>
<h3 id="merge-sorter-c中函数的说明：">merge-sorter.c中函数的说明：</h3>
<p><code>static void next_step(sorter_t *b);</code></p>
<p>该函数实现归并排序执行下一步操作的功能，利用非递归的方式实现递归的归并排序算法，使之能够单步进行。具体而言，当排序算法不处于SORTER_SORTING或者SORTER_PAUSED状态时，直接返回，反之继续，并设置frame_cnt为0。该函数将整个排序过程分为三个内部状态：MERGE_STEP1、MERGE_STEP2、MERGE_STEP3。处于MERGE_STEP1时，函数首先判断排序是否完成，若未完成，则利用while循环找出本次需要排序的子列（子列本身未完成排序，但其前后两部分均已完成排序），然后进入MERGE_STEP2。处于MERGE_STEP2时，函数将需要排序的子列分为前后两个部分，并依序比较两部分中各元素大小，将比较结果储存至me-&gt;doing_list[]中，然后进入MERGE_STEP3。在MERGE_STEP3状态下，函数将me-&gt;doing_list[]中的元素赋值给nums[]中的对应子列，最后重新进入MERGE_STEP1状态寻找下一个需要排序的子列。至此该函数已完成一次子列排序，之后函数将重复这三个过程，直到排序完成。</p>
<p>b: 归并排序结构体成员base的地址</p>
<p><code>static void display(sorter_t *b);</code></p>
<p>如果状态是SORTER_UNREADY时，调用sorter_display_unready()函数并返回，反之继续。该函数以柱状图的形式可视化当前排序状态，其将绘图区域分为上下两部分，上半部分绘制me-&gt;doing_list[]中的数据，下半部分绘制nums[]中的数据。对于已经排序过的数据绘制为深灰色Dark Gray，对于未排序过的数据绘制为浅灰色Light Gray，对于正在排序的数据绘制为橘黄色Orange，对于正在进行比较的数据， 分别绘制为红色Red和绿色Green。同时如果数据量过多导致柱宽度小于0.05那么不绘制边框。</p>
<p>b: 归并排序成员base的地址</p>
<p><code>static void restart(sorter_t *b);</code></p>
<p>重置归并排序过程，调用sorter_restart(b)然后重置i、j、k为0，状态为MERGE_STEP1状态。</p>
<p>b: 归并排序结构体成员base的地址</p>
<p><code>static void destroy(sorter_t *b);</code></p>
<p>和冒泡排序的destroy函数功能完全一样，只是释放内存。</p>
<p>b: 归并排序结构体成员base的地址</p>
<p><code>static int Check(double Arr[],int StartIndex, int EndIndex, bool flag);</code></p>
<p>检查输入数组是否已完成排序。</p>
<p>返回值：1：已完成排序；0：未完成排序</p>
<p><code>static bool save_state(sorter_t *b, char const *ofile);</code></p>
<p>保存归并排序算法的状态到文件ofile。类似于bubble-sorter.c中的save_state一样。第一行输出“!!merge sort state file!!”，然后调用sorter_save_state_at()保存成员变量base的状态，之后输出状态state；输出start，end，mid的值；输出doing_list数组的值；输出i，j，k的值。</p>
<p>b: 归并排序结构体成员base的地址</p>
<p>ofile: 存储状态的文件</p>
<p>返回值：true: 保存成功，false：保存失败</p>
<p><code>sorter_t *merge_sorter_create(void);</code></p>
<p>分配merge_sort_t类型结构体，并初始化。包括设置base成员的各个函数指针以及i，j，k设置为0，state设置为MERGE_STEP1</p>
<p>返回值： 归并排序结构体成员base的地址，如果分配内存失败返回NULL</p>
<p><code>sorter_t *merge_sorter_load(char const *state_file);</code></p>
<p>从状态文件中读取数据并初始化归并排序结构体 merge_sorter_t。具体来说，首先读取第一行判断是不是为“!!merge sort state file!!”，成功的话继续使用 sorter_load_from()从文件流中继续读取数据并初始化base成员，之后继续读取状态state，读取start，end，mid的值，读取doing_list数组的数据，读取i，j，k的值。</p>
<p>state_file：状态文件名</p>
<p>返回值：初始化好的归并排序结构体内部base成员的地址；如果加载或初始化失败返回NULL</p>
<h3 id="insertion-sorter-c中函数的说明：">insertion-sorter.c中函数的说明：</h3>
<p><code>static void next_step(sorter_t *b);</code></p>
<p>插入排序执行下一步操作。具体来说，当排序算法没有处于SORTER_SORTING或者SORTER_PAUSED状态时，直接返回，反之继续，并设置frame_cnt为0。排序过程分为3个内部状态：INSERTION_STEP1, INSERTION_STEP2, INSERTION_STEP3。处于INSERTION_STEP1时，其将nums[i]的值赋值给doing_list[i]，并进入INSERTION_STEP2。在INSERTION_STEP1状态中，函数将待排序数据（doing_list[k]）与相邻数据(nums[k-1]])进行比较，若顺序有误，则交换数据，以此来确定待排序数据的位置，然后进入INSERTION_STEP3。在INSERTION_STEP1状态下，函数将doing_list[k]的值赋值给nums[k]。重复上述三个状态，直到所有元素完成排序</p>
<p>b: 插入排序结构体成员base的地址</p>
<p><code>static void display(sorter_t *b);</code></p>
<p>如果状态是SORTER_UNREADY时，调用sorter_display_unready()函数并返回，反之继续。该函数以柱状图的形式可视化当前排序状态，其将绘图区域分为上下两部分，上半部分绘制me-&gt;doing_list[]中的数据，下半部分绘制nums[]中的数据。对于未排序过的数据绘制为浅灰色Light Gray，对于正在排序的数据绘制为橘黄色Orange，对于正在进行比较的数据， 分别绘制为红色Red和绿色Green，排序完成后数据绘制为深灰色Dark Gray。同时如果数据量过多导致柱宽度小于0.05那么不绘制边框。</p>
<p>b: 插入排序成员base的地址</p>
<p><code>static void restart(sorter_t *b);</code></p>
<p>重置插入排序过程，调用sorter_restart(b)然后重置i，k为0，flag为0，状态为INSERTION_STEP1状态。</p>
<p>b: 插入排序结构体成员base的地址</p>
<p><code>static void destroy(sorter_t *b);</code></p>
<p>释放内存，通过container_of计算出包含b的结构体起始地址然后调用free()释放内存。</p>
<p>b: 插入排序结构体成员base的地址</p>
<p><code>static bool save_state(sorter_t *b, char const *ofile);</code></p>
<p>保存快速排序算法的状态到文件ofile。类似于bubble-sorter.c中的save_state一样。第一行输出“!!insertion sort state file!!”，然后调用sorter_save_state_at()保存成员变量base的状态，之后输出i，k的值；输出doing_list数组的值，输出状态state，flag的值。</p>
<p>b: 插入排序结构体成员base的地址</p>
<p>ofile: 存储状态的文件</p>
<p>返回值：true: 保存成功，false：保存失败</p>
<p><code>sorter_t *insertion_sorter_create(void);</code></p>
<p>分配insertion_sort_t类型结构体，并初始化。包括设置base成员的各个函数指针以及i，k设置为0，flag设置为1，状态为INSERTION_STEP1</p>
<p>返回值： 插入排序结构体成员base的地址，如果分配内存失败返回NULL</p>
<p><code>sorter_t *insertion_sorter_load(char const *state_file);</code></p>
<p>从状态文件中读取数据并初始化插入排序结构体 insertion_sorter_t。具体来说，首先读取第一行判断是不是为“!!insertion sort state file!!”，成功的话继续使用 sorter_load_from()从文件流中继续读取数据并初始化base成员，之后继续读取i，k的值，读取doing_list数组的数据，读取状态state，读取flag的值。</p>
<p>state_file：状态文件名</p>
<p>返回值：初始化好的插入排序结构体内部base成员的地址；如果加载或初始化失败返回NULL</p>
<h3 id="utility-h中宏的说明：">utility.h中宏的说明：</h3>
<p><code>ARRAY_SIZE(arr)</code></p>
<p>求出数组元素个数，使用 sizeof(arr) 求出数组占的内存大小，除以sizeof(arr[0])一个元素占的大小，得出有多少个元素</p>
<p><code>container_of(ptr, type, member)</code></p>
<p>根据type类型中member成员的地址求出type类型的地址，具体就是ptr地址减去member在type类型中的偏移量使用 ptr – offset(type, member)来求出</p>
<h3 id="utility-c中函数的说明：">utility.c中函数的说明：</h3>
<p><code>double min_nums(double const *nums, int size);</code></p>
<p>求出数组中的最小值</p>
<p>nums, size: 用于表示数组</p>
<p>返回值：最小值</p>
<p><code>double max_nums(double const *nums, int size);</code></p>
<p>类似double min_nums(); 只是返回的是最大值</p>
<p><code>static int random_int(int lo, int hi);</code></p>
<p>使用公式 rand()/(double)RAND_MAX * (1+hi – lo) + lo生成[lo, hi]区间的随机整数</p>
<p>lo, hi: 生成的随机数最小值和最大值</p>
<p>返回值：生成的随机数</p>
<p><code>double *random_nums(int lo, int hi, int size);</code></p>
<p>反复调用random_int(lo, hi) 生成size个随机整数并放到动态分配内存的数组里。</p>
<p>lo, hi: 生成随机整数的最小值和最大值</p>
<p>size: 生成的个数</p>
<p>返回值：含有size个随机整数的数组</p>
<p><code>double *load_nums(char const *name, int *size, int *ptype);</code></p>
<p>从名为name的文件里读取数据，然会数据数组的地址并把数据大小和数据类型分别存到size指针和ptype里，具体来说首先打开文件name为输入流 istream，然后简介调用load_nums_from()完成具体解析操作。数据文件里数据格式为课程文档中规定的格式。</p>
<p>name: 文件名</p>
<p>size: 指向存储数据大小的指针</p>
<p>返回值：动态分配的数组的起始地址，如果加载失败返回NULL</p>
<p><code>double *load_nums_from(FILE *istream, int *psize, int *type);</code></p>
<p>从文件流中读取并解析数据，首先读取一个字符串判断是否是int、float和double中之一，相应给type设置为SORTER_INT、SORTER_FLOAT、SORTER_DOUBLE，紧接着根据类型读取数据，直到读取数据结束，设置psize的值为读取的数据个数。然后返回数组。</p>
<p>istream: 输入流</p>
<p>psize: 存储文件大小的地址</p>
<p>type: 存储文件类型的地址</p>
<p>返回值：NULL读取失败；读取成功返回数组地址</p>
<p><code>bool save_nums_at(FILE *ostream, double const *nums, int size, int type)</code></p>
<p>把地址时nums大小为size的数组的数字存入流ostream中。首先根据type决定输出int、float还是double字符串，紧接着输出nums中的数并按照空格隔开。</p>
<p>ostream: 输出流</p>
<p>nums: 数组地址</p>
<p>size: 数组大小</p>
<p>type: 数据类型</p>
<p>返回值：true写入成功，false写入失败</p>
<p><code>bool save_nums(char const *ofile, double const *nums, int size, int type);</code></p>
<p>存储数据到文件，内部首先打开文件为输出流ostream，然后调用save_nums_at()实现真正的存储操作。</p>
<p>ofile: 输出保存的文件名</p>
<p>nums, size：输出的数据</p>
<p>type: 数据的类型</p>
<p>返回值：true 存储成功，false 存储失败</p>
</article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%8F%AF%E8%A7%86%E5%8C%96/">可视化</a></div><div class="post_share"><div class="social-share" data-image="/img/visual-sort.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button button--animated"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechatpay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/wechatpay.jpg" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/alipay.jpg" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021/08/07/%E9%AB%98%E6%80%A7%E8%83%BD%E7%BC%93%E5%AD%98/"><img class="prev-cover" src="/img/java.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">高性能缓存</div></div></a></div><div class="next-post pull-right"><a href="/2021/03/11/%E3%80%8A%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0%E3%80%8B%E7%AC%AC%E5%85%AD%E7%AB%A0/"><img class="next-cover" src="/img/c++logo.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">《算法笔记》第六章</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-info-avatar is-center"><img class="avatar-img" src="/img/profile.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-info__name">执酒天涯</div><div class="author-info__description">浙江大学19级高分子系在读本科渣渣</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">12</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">7</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">5</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/charliezhang6"><i class="fab fa-github"></i><span>关注我</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/charliezhang6" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:charliezhang@zju.edu.cn" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="/img/wechat.jpg" target="_blank" title="WeChat"><i class="fab fa-weixin"></i></a><a class="social-icon" href="/img/qq.jpg" target="_blank" title="QQ"><i class="fab fa-qq"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">欢迎来到我的小站，广告位招租，量大价优</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">1.</span> <span class="toc-text">visual-sort</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%AF%E8%AF%AD%E8%AF%B4%E6%98%8E"><span class="toc-number">1.0.1.</span> <span class="toc-text">术语说明</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E4%BD%93%E6%A1%86%E6%9E%B6%E8%AE%BE%E8%AE%A1"><span class="toc-number">1.1.</span> <span class="toc-text">总体框架设计</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%9F%E8%83%BD%E6%A8%A1%E5%9D%97%E8%AE%BE%E8%AE%A1"><span class="toc-number">1.2.</span> <span class="toc-text">功能模块设计</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1"><span class="toc-number">1.3.</span> <span class="toc-text">数据结构设计</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E6%96%87%E4%BB%B6%E6%9E%84%E6%88%90%E6%9C%BA%E5%88%B6"><span class="toc-number">1.3.1.</span> <span class="toc-text">多文件构成机制</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">2.</span> <span class="toc-text">函数设计描述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#main-c%E6%96%87%E4%BB%B6%E4%B8%AD%E5%87%BD%E6%95%B0%E7%9A%84%E8%AF%B4%E6%98%8E%EF%BC%9A"><span class="toc-number">2.0.1.</span> <span class="toc-text">main.c文件中函数的说明：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#main-view-c%E4%B8%AD%E5%87%BD%E6%95%B0%E7%9A%84%E8%AF%B4%E6%98%8E%EF%BC%9A"><span class="toc-number">2.0.2.</span> <span class="toc-text">main-view.c中函数的说明：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#about-view-c%E4%B8%AD%E5%87%BD%E6%95%B0%E7%9A%84%E8%AF%B4%E6%98%8E%EF%BC%9A"><span class="toc-number">2.0.3.</span> <span class="toc-text">about-view.c中函数的说明：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sorter-c%E4%B8%AD%E5%87%BD%E6%95%B0%E7%9A%84%E8%AF%B4%E6%98%8E%EF%BC%9A"><span class="toc-number">2.0.4.</span> <span class="toc-text">sorter.c中函数的说明：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#bubble-sorter-c%E4%B8%AD%E5%87%BD%E6%95%B0%E7%9A%84%E8%AF%B4%E6%98%8E%EF%BC%9A"><span class="toc-number">2.0.5.</span> <span class="toc-text">bubble-sorter.c中函数的说明：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#select-sorter-c%E4%B8%AD%E5%87%BD%E6%95%B0%E7%9A%84%E8%AF%B4%E6%98%8E%EF%BC%9A"><span class="toc-number">2.0.6.</span> <span class="toc-text">select-sorter.c中函数的说明：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#merge-sorter-c%E4%B8%AD%E5%87%BD%E6%95%B0%E7%9A%84%E8%AF%B4%E6%98%8E%EF%BC%9A"><span class="toc-number">2.0.7.</span> <span class="toc-text">merge-sorter.c中函数的说明：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#insertion-sorter-c%E4%B8%AD%E5%87%BD%E6%95%B0%E7%9A%84%E8%AF%B4%E6%98%8E%EF%BC%9A"><span class="toc-number">2.0.8.</span> <span class="toc-text">insertion-sorter.c中函数的说明：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#utility-h%E4%B8%AD%E5%AE%8F%E7%9A%84%E8%AF%B4%E6%98%8E%EF%BC%9A"><span class="toc-number">2.0.9.</span> <span class="toc-text">utility.h中宏的说明：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#utility-c%E4%B8%AD%E5%87%BD%E6%95%B0%E7%9A%84%E8%AF%B4%E6%98%8E%EF%BC%9A"><span class="toc-number">2.0.10.</span> <span class="toc-text">utility.c中函数的说明：</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/04/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" title="设计模式"><img src="/img/java/jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="设计模式"/></a><div class="content"><a class="title" href="/2022/04/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" title="设计模式">设计模式</a><time datetime="2022-04-28T04:38:36.000Z" title="发表于 2022-04-28 12:38:36">2022-04-28</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/04/28/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA/" title="JVM虚拟机"><img src="/img/jvm.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="JVM虚拟机"/></a><div class="content"><a class="title" href="/2022/04/28/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA/" title="JVM虚拟机">JVM虚拟机</a><time datetime="2022-04-28T04:32:35.000Z" title="发表于 2022-04-28 12:32:35">2022-04-28</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/01/14/%E6%95%B0%E6%8D%AE%E5%BA%93/" title="数据库"><img src="/img/mysql.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="数据库"/></a><div class="content"><a class="title" href="/2022/01/14/%E6%95%B0%E6%8D%AE%E5%BA%93/" title="数据库">数据库</a><time datetime="2022-01-14T09:35:08.000Z" title="发表于 2022-01-14 17:35:08">2022-01-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/12/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" title="数据结构和算法"><img src="/img/c++logo.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="数据结构和算法"/></a><div class="content"><a class="title" href="/2021/12/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" title="数据结构和算法">数据结构和算法</a><time datetime="2021-12-11T02:10:21.000Z" title="发表于 2021-12-11 10:10:21">2021-12-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/10/14/%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F/" title="秒杀系统"><img src="/img/taobao.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="秒杀系统"/></a><div class="content"><a class="title" href="/2021/10/14/%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F/" title="秒杀系统">秒杀系统</a><time datetime="2021-10-14T09:35:08.000Z" title="发表于 2021-10-14 17:35:08">2021-10-14</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2021 - 2022 By 执酒天涯</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">欢迎光临我的小站</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/search/local-search.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex@latest/dist/contrib/copy-tex.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/contrib/copy-tex.css"><script>(() => {
  document.querySelectorAll('#article-container span.katex-display').forEach(item => {
    btf.wrap(item, 'div', '', 'katex-wrap')
  })
})()</script></div><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/fireworks.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>