<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>排序算法可视化</title>
      <link href="2021/06/14/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
      <url>2021/06/14/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%8F%AF%E8%A7%86%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h1>visual-sort</h1><p>基于libgraphics和imgui的排序可视化算法</p><h3 id="术语说明">术语说明</h3><p>sorter：指的是排序算法对象，sorter是一个结构体，其包含了一些字段和函数指针，不同的排序算法都要包含这个结构体，同时实现相关函数并给函数指针赋值，以实现某种多态性。本程序实现了五个具体的排序算法，冒泡排序 bubble sorter、快速排序 quick sorter、归并排序 merge sorter、插入排序 insertion sorter和选择排序 select sorter，同时可以方便添加其他排序算法，只要符合接口即可。具体见后文数据结构设计。</p><p>view：指的是视图，界面看见的部分称为 view，程序支持多个视图，通过函数 view_switch(view_name) 切换到不同的视图，类似与手机页面的切换。同时，view结构体也类似上述排序对象作为一个基类，本程序具体实现了 main-view 视图和 about-view 视图。前者是主要的排序界面，后者是程序的关于说明的页面。</p><p>menu: 指的是菜单栏或者菜单下拉框。</p><h2 id="总体框架设计">总体框架设计</h2><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1grhwgmxbtqj30o20foq5p.jpg" alt="图片 1"></p><h2 id="功能模块设计">功能模块设计</h2><p>为何实现高内聚低耦合，主要划分了视图模块、排序算法模块、通用工具模块和设置模块。</p><p>视图模块主要是由view.h、view.c、main-view.h、main-view.c、about-view.h和about-view.c构成。view.h和view.c分别是视图的基础结构和接口，以及视图操作的基本函数的实现；main-view.h和main-view.c是主视图（也就是排序页面）的实现；about-view.h和about-view.c是关于视图的实现，主要内容是作者名单。当然，后续可以继续添加新的视图，只需要实现view.h中的接口就可以。</p><p>排序模块有sorter.h、sorter.c、bubble-sorter.h、bubble-sorter.c、quick-sorter.h、quick-sorter.c、select-sorter.h、select-sorter.c、merge-sorter.h、merge-sorter.c、insertion-sorter.h、insertion-sorter.c文件构成，后续可以继续添加其他排序算法的可视化。和view.h一样，sorter.h、sorter.c是排序算法的基础结构和共同接口，bubble-sorter.c是冒泡排序的实现，quick-sorter.c是快速排序算法的实现，select-sorter.c是选择排序的实现，merge-sorter.c是归并排序的实现，insertion-sorter.c是插入排序的实现。</p><p>通用工具模块是 utility.h和utility.c实现，主要包括了一些通用的算法，比如最大值、最小值和随机数生成等算法的实现。</p><p>设置模块是 setting.h，主要定义了程序的一些基本属性，比如窗口大小等。</p><p>最后是主模块，也叫入口模块，只有一个文件main.c，里面是一些初始化工作，注册各个视图，通过定时器驱动页面的刷新等。</p><h2 id="数据结构设计">数据结构设计</h2><p>主要的数据结构有视图相关的<code> view_t</code>、<code>main_view_t</code>和<code>about_view_t</code>、排序算法相关的<code>sorter_t</code>、<code>bubble_sorter_t</code>、<code>quick_sorter_t</code>、<code>merge_sorter_t</code>、<code>insertion_sorter_t</code>和<code>select_sorter_t</code>。</p><p><code>view_t </code>结构体定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">view_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> <span class="keyword">const</span>* name;</span><br><span class="line">    <span class="keyword">void</span> (*display)(<span class="keyword">view_t</span> *me);</span><br><span class="line">    <span class="keyword">void</span> (*destroy)(<span class="keyword">view_t</span> *me);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其中<code>name</code>是视图名字，后续通过此名字来确定视图。<code>display</code>是函数指针，指向一个所谓的显示函数，用于把确定如何把此视图内容呈现到屏幕上，<code>destroy</code>是也是函数指针用于释放自定义视图的内存。具体如何工作起来的见下文对<code>main_view</code>和<code>about_view_t</code>的分析。</p><p><code>main_view_t</code>这是最为主要的视图，也就是排序页面的视图，定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">    DATASRC_RANDOM = <span class="number">1</span>,</span><br><span class="line">    DATASRC_ASCEND,</span><br><span class="line">    DATASRC_DESCEND,</span><br><span class="line">    DATASRC_LOADFILE,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span> SIZE_TEXT_MAX = <span class="number">64</span> &#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">main_view_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">view_t</span> base;</span><br><span class="line">    <span class="keyword">sorter_t</span> *sorter;</span><br><span class="line">    <span class="keyword">int</span> src_idx;</span><br><span class="line">    <span class="keyword">double</span> *nums;</span><br><span class="line"><span class="keyword">int</span> size;</span><br><span class="line"><span class="keyword">int</span> type;</span><br><span class="line">    <span class="keyword">char</span> size_text[SIZE_TEXT_MAX];</span><br><span class="line">&#125; <span class="keyword">main_view_t</span>;</span><br></pre></td></tr></table></figure><p>可以看见``main_view_t<code>结构体内嵌了</code>view_t<code>结构体，取名为</code> base <code>意味基类，这样可以让</code>main_view_t<code>具有</code>view_t<code>的性质；</code>sorter<code>的指针指向一个排序算法结构体，用于表明当前使用什么排序算法，具体来说可能是冒泡排序、快速排序、选择排序、归并排序、插入排序。</code>src_idx<code>是用于表明数据来源选择的是哪一个，取值为</code>DATASRC_RANDOM<code>表示随机生成，</code>DATASRC_ASCEND<code>表示随机生成升序数据，</code>DATASRC_DESCEND<code>表示随机生成降序数据，</code>DATASRC_LOADFILE<code>表示数据从文件加载，具体从当前目录下的“input.txt”读取数据；</code>nums<code>指针和</code>size<code>表明当前生成或加载的数据数组的地址和大小；</code>type<code>表示数据类型，可以取值为</code>SORTER_INT<code> 表明数据类型是整数，</code>SORTER_FLOAT<code>表示数据类型是浮点数，</code>SORTER_DOUBLE<code>表示数据类型是双精度浮点数；</code>size_text<code>是为了从界面上交互显示并输入</code>size<code>大小的缓冲区，最大长度为</code>SIZE_TEXT_MAX<code>长。这里常量使用 </code>enum<code>而不是通常的</code>#define`宏来定义，是为了方便编译后方便调试时具有符号，而不是简简单单的数字。</p><p><code>about_view_t</code>结构体很简单</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">about_view_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">view_t</span> base;</span><br><span class="line">&#125; <span class="keyword">about_view_t</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">和main_view_t结构体一样，不做介绍</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><code>sorter_t</code>排序算法结构体，思想和<code>view_t</code>结构体思想一致</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">    NUMS_SIZE_MIN = <span class="number">10</span>,  <span class="comment">// 自动生成的数据最少个数</span></span><br><span class="line">    NUMS_SIZE_DFT = <span class="number">30</span>,  <span class="comment">// 默认生成的数据个数</span></span><br><span class="line">    NUMS_SIZE_MAX = <span class="number">1024</span>,<span class="comment">// 最多的数据个数</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">    SORTER_UNREADY = <span class="number">0</span>,</span><br><span class="line">    SORTER_READY,</span><br><span class="line">    SORTER_SORTING,</span><br><span class="line">    SORTER_PAUSED,</span><br><span class="line">    SORTER_SORTED,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">    SORTER_INT = <span class="number">0</span>,</span><br><span class="line">    SORTER_FLOAT,</span><br><span class="line">    SORTER_DOUBLE,</span><br><span class="line">    SORTER_TYPE_MAX,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sorter_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">double</span> *nums;</span><br><span class="line">    <span class="keyword">double</span> *nums_back;</span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line">    <span class="keyword">double</span> min, max;</span><br><span class="line">    <span class="keyword">int</span> type;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">double</span> speed;</span><br><span class="line">    <span class="keyword">int</span> frame_cnt;</span><br><span class="line">    <span class="keyword">int</span> state;</span><br><span class="line">    <span class="keyword">bool</span> ascend;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> (*next_step)(<span class="keyword">sorter_t</span> *me);</span><br><span class="line">    <span class="keyword">void</span> (*display)(<span class="keyword">sorter_t</span> *me, <span class="keyword">double</span> x, <span class="keyword">double</span> y, <span class="keyword">double</span> w, <span class="keyword">double</span> h);</span><br><span class="line">    <span class="keyword">void</span> (*restart)(<span class="keyword">sorter_t</span> *me);</span><br><span class="line">    <span class="keyword">void</span> (*destroy)(<span class="keyword">sorter_t</span> *me);</span><br><span class="line">    <span class="keyword">bool</span> (*save_state)(<span class="keyword">sorter_t</span> *me, <span class="keyword">char</span> <span class="keyword">const</span> *ofile);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>nums</code>和<code>size</code>都是用于记录排序的数据的信息的，<code>nums_back</code>是对未排序前的<code>nums</code>的数据的备份，用于实现重新排序的功能。正如注释提到的一样 <code>nums </code>指向的内存所有权不是<code>sorter_t</code>的而是外部的，需要外界释放内容，但是<code>nums_back</code>是此结构体分配的，所以需要自己释放。<code>min</code>和<code>max</code>分别记录数据中的最大值和最小值，用于后面绘图时使用。type表示被排序的数据类型取值为<code>SORTER_INT</code>、<code>SORTER_FLOAT</code>、<code>SORTER_DOUBLE</code>分别表示int类型，float类型和double类型的数据。</p><p><code>speed</code>记录可视化排序过程的快慢，每秒多少步。``frame_cnt<code>记录从上一步到现在界面刷新了多少帧（多少次画面）。</code>state<code>记录排序算法的状态，取值有</code>SORTER_UNREADY<code>，表示排序算法为准备好，也就是数据没有被提供；</code>SORTER_READY<code>表示排序算法准备好了，下一步可以进行排序；</code>SORTER_SORTING<code>表示算法正在排序过程中；</code>SORTER_PAUSED<code>表示排序算法被暂停，后续可以恢复继续排序；</code>SORTER_SORTED<code>表示排序过程结束，数据已经排好序了。</code>ascend<code>表示排序的顺序，升序还是降序，当</code>ascend<code>为真表示按照升序排序（也是默认排序方式），当</code>ascend`为假表示按照降序排序。</p><p>函数指针<code>next_step</code>用于记录子结构的实现下一步操作的函数的地址；<code>display</code>用于实现如何可视化排序的内部情况；<code>restart</code>用于重新操作结构体内部变量，实现重新排序的功能；<code>destroy</code>用于记录如何释放结构体内存；<code>save_state</code>用于存储当前状态到文件里。</p><p><code>bubble_sorter_t</code>结构体是<code>sorter_t</code>的子结构体，是对冒泡排序算法的具体实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">bubble_sorter_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">sorter_t</span> base;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> k;  <span class="comment">// 排序好了多少个元素</span></span><br><span class="line">    <span class="keyword">int</span> i;  <span class="comment">// 当前这一轮进行到哪个元素</span></span><br><span class="line">&#125; <span class="keyword">bubble_sorter_t</span>;</span><br></pre></td></tr></table></figure><p><code>base</code>是排序算法的基类，k和i变量的含义正如注释里写的一样。</p><p>快速排序是一个比较复杂的排序算法，所以其对应结构体也较为复杂：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span> STACK_MAX = <span class="number">1024</span> &#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">quick_sorter_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">sorter_t</span> base;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">stack</span>[STACK_MAX][<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">int</span> stack_size;</span><br><span class="line">    <span class="keyword">int</span> done_list[NUMS_SIZE_MAX];</span><br><span class="line">    <span class="keyword">int</span> done_size;</span><br><span class="line">    <span class="keyword">int</span> state;</span><br><span class="line">    <span class="keyword">int</span> lo, hi;</span><br><span class="line">    <span class="keyword">int</span> l, r;</span><br><span class="line">    <span class="keyword">int</span> pivot_idx;</span><br><span class="line">&#125; <span class="keyword">quick_sorter_t</span>;</span><br></pre></td></tr></table></figure><p>同样的<code>base</code>是基类结构体，二维数据<code>stack</code>用于记录递归的情况，最大递归深度<code>STACK_SIZE</code>为1024，<code>stack[i][0]</code>表示递归深度为i时左边界，<code>stack[i][1]</code>表示递归深度为i时右边界。``done_list<code>和</code>done_size<code>用于记录哪些下标的元素已经被排好序了，方便可视化时特别展示出来。</code>state<code>同样用于记录快速排序的内部状态。</code>lo<code>和</code>hi<code>记录当前轮快速排序正在处理的元素的左右边界下标分别是多少，</code>l<code>和</code>r<code>时记录元素划分时左边和右边的下标，</code>pivot_idx`记录枢纽元的下标是多少。</p><p><code>select_sorter_t</code>对应的是选择排序</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">select_sorter_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">sorter_t</span> base;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> k;  <span class="comment">// 排序好了多少个元素</span></span><br><span class="line"><span class="keyword">int</span> i;  <span class="comment">// 当前这一轮进行到哪个元素</span></span><br><span class="line"><span class="keyword">int</span> max;  <span class="comment">// 当前这一轮最值下标</span></span><br><span class="line">&#125; <span class="keyword">select_sorter_t</span>;</span><br></pre></td></tr></table></figure><p>比起冒泡排序多了一个<code>max</code>值用于标记当前这轮所确定的最值下标</p><p><code>merge_sorter_t</code>结构体对应的是归并排序，具体如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">merge_sorter_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">sorter_t</span> base;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> doing_size;   </span><br><span class="line"><span class="keyword">double</span> doing_list[NUMS_SIZE_MAX];   </span><br><span class="line"><span class="keyword">int</span> start,end,mid;  </span><br><span class="line"><span class="keyword">int</span> state;</span><br><span class="line"><span class="keyword">int</span> i,j,k;</span><br><span class="line">&#125; <span class="keyword">merge_sorter_t</span>;</span><br></pre></td></tr></table></figure><p>与上述结构相同<code>base</code>是基类结构体，<code>doing_size</code>记录正在排序的元素个数，<code>doing_list[]</code>用于记录正在排序的元素，<code>start</code>,<code>end</code>,<code>mid</code>用于标记正在排序部分的始末和中间下标，<code>state</code>用于记录归并排序的内部状态，<code>i</code>，<code>j</code>，<code>k</code>用于记录当前正在比较的元素下标。</p><p><code>insertion_sorter_t</code>结构体对应的是插入排序，具体如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">insertion_sorter_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">sorter_t</span> base;</span><br><span class="line">  <span class="keyword">int</span> k;</span><br><span class="line">  <span class="keyword">int</span> i;  </span><br><span class="line">  <span class="keyword">int</span> flag; </span><br><span class="line">  <span class="keyword">int</span> state;</span><br><span class="line"><span class="keyword">double</span> doing_list[NUMS_SIZE_MAX];</span><br><span class="line">&#125; <span class="keyword">insertion_sorter_t</span>;</span><br></pre></td></tr></table></figure><p>与上述结构相同<code>base</code>是基类结构体，<code>k</code>记录当前排序元素移动的位置，<code>i</code>记录当前排序元素的起始下标，<code>flag</code>记录绘制数据的状态，<code>state</code>用于记录插入排序的内部状态，<code>doing_list[]</code>用于记录正在排序的元素。</p><h3 id="多文件构成机制">多文件构成机制</h3><p>为了实现多文件编译，每个头文件都定义了<code>#ifndef FILENAME_H</code>__，<code>#define FILENAME_H__</code>和<code>#endif</code>宏，把正常内容包含其中以实现每次<code>#include</code>只被引入一次，以防止出现重复声明和定义。同时每个*.c文件都有对应的*.h文件，里面声明了可以从*.c中使用的外部函数的原型，如果是 <em>.c 文件中的私有函数（不希望外部可以使用的函数）加上 static 限制作用域为本</em>.c文件。如果是*.h头文件中定义的变量，通常都是希望是私有的所以有static修饰作用域为本文件以防止出现链接错误。对于内联函数比如<code>void swap(double *a, double \*b)</code>也是用<code>static</code>修饰，以防止出现链接时多次定义，本程序没有使用外部变量，所以不需要外部变量的链接问题。虽然在*.c文件中定义了外部变量，但是这些变量都是默认为本文件内使用，所以不会被其他文件所感知到。</p><h1>函数设计描述</h1><h3 id="main-c文件中函数的说明：">main.c文件中函数的说明：</h3><p><code>void Mian(void);</code></p><p>此函数主要完成初始化工作，包括调用 InitGraphic()以初始化graphics环境，调用 initGUI完成ImGUI库的初始化，调用 initialize() 函数完成本程序其他模块的初始化，注册destroy()函数到程序退出时候以释放资源，设置窗口标题为 Visual Sort，把ImGUI的uiGetChar()、uiGetKeyboard()、uiGetMouse()注册到graphic库中，以获得鼠标键盘等情况，同时注册一个定时器id为1的定时器。</p><p><code>  static void main_loop_timer_handler(int timeid);</code></p><p>函数首先调用DisplayClear()函数清屏，然后调用 view_display()函数显示当前活动的view页面到屏幕上。</p><p>timeid: 是此函数注册到定时器id</p><p><code>static void initialize(void);</code></p><p>创建并添加两个视图 main 和 about到视图管理模块中，并设置默认主题颜色为4号</p><p><code>static void destroy(void);</code></p><p>调用 view_destroy() 释放所有视图的内存</p><p>view.c文件中函数的说明：在这个文件中有三个文件内作用域的全局变量 view_t *views[VIEWS_MAX]、 int view_cnt和    view_t *active，第一个和第二个变量共同记录所有的视图，active指向当前活动的视图。</p><p><code>static void view_lookup_by_name(char const *name);</code></p><p>查找视图名字为name的视图的下标，没找到返回 VIEW_NOTFOUND (-1)。</p><p>name: 需要查找的视图的名字</p><p><code> int view_default(char const *name);</code></p><p>设置默认活动的视图，内部间接调用 view_switch(name) 实现，具体见下面分析。</p><p>name: 视图的名字</p><p><code> void view_display(void);</code></p><p>调用当前活动的视图的display()，在屏幕上显示视图的内容。</p><p><code> int view_switch(char const *name);</code></p><p>切换名为name的视图为活动视图，内部使用 view_lookup_by_name(name) 找到视图下标，然后修改 active = views[idx] 以便设置为活动视图。</p><p>name: 视图名字</p><p>返回值：VIEW_NOTFOUND 名为name的视图没有找到</p><p>​    VIEW_OK 切换成功</p><p><code> int view_add(view_t *view);</code></p><p>通过查找 views 是否有空余位置，然后把 view 添加到里面去。</p><p>view: 待添加的视图</p><p>返回值：VIEW_INVALID 视图 view 为空指针，不合法</p><p>​    VIEW_TOOMANY 添加的视图过多</p><p>​    VIEW_OK 添加视图成功</p><p><code>static void view_remove_by_idx(int idx);</code></p><p>移除下标为 idx 处的视图，并调用其注册的销毁函数，同时把 views[idx] 置为NULL</p><p>idx: 视图的下标</p><p><code>int view_remove(char const *name);</code></p><p>通过使用 view_lookup_by_name(name) 找到视图的索引 idx，然后使用 view_remove_by_idx(idx)删除这个视图。</p><p>name: 视图名字</p><p>返回值：VIEW_NOTFOUND 名为name视图没有找到</p><p>​    VIEW_OK 删除成功</p><p><code>void view_destroy(void);</code></p><p>销毁所有记录在views里的视图，并置view_cnt为0，active为NULL</p><h3 id="main-view-c中函数的说明：">main-view.c中函数的说明：</h3><p><code>view_t *main_view_create(char const *name);</code></p><p>创建名为 name 的 main_view_t 类型结构体，内部会为 main_view_t 分配空间并初始化，包括初始化基类 view_t，设置 view_t 结构体里的display和destroy函数指针为本文定义的display和 destroy函数。设置默认的排序算法为冒泡排序。</p><p>name: 视图名字</p><p>返回值：main_view_t 结构体内部成员基类 base 的地址，这个类型是 view_t 类型的</p><p><code>static void display(view_t *b);</code></p><p>显示视图，对于main_view_t 类型而言，首先调用 container_of从b计算出子类的地址赋值给me变量。然后分别调用menubar_display()、leftside_column_display()、drawLine()显示界面的菜单栏、左边控制部分界面和左右部分分界线。之后使用sorter_update(me-&gt;sorter)更新排序算法的内部，随后调用sorter-&gt;display()把排序可视化到屏幕。</p><p>b: 视图的基类，main_view_t内包含的base成员的地址</p><p><code>static void destroy(view_t *b);</code></p><p>释放生成的数据，释放sorter结构体，释放本结构所占的内存。</p><p>b: 视图的基类，main_view_t内包含的base成员的地址</p><p><code>static void leftside_column_display(main_view_t *me, double x, double y, double w, double h);</code></p><p>显示左侧控制按钮。内部调用了data_source_display()显示获取数据的控件，显示了选择算法的下拉菜单，排序顺序的按钮，控件排序速度的控件，排序状态、控制状态和保存状态的按钮。同时这些按钮根据排序状态的不同可能是不可以交互的，比如当数据没有准备好时，排序按钮不会显示，当排序进行过程中，选择数据源和排序算法的下拉菜单不可以交互，直到重新排序或者排序完成才可以重新交互。</p><p>me: main_view_t 类型的结构体地址</p><p>x, y, w, h: 在坐标(x,y)处显示，长宽分别是w, h英寸</p><p><code>static double data_source_display(main_view_t *me, double x, double y, double w, double h);</code></p><p>首先显示“Load Saved State”的按钮，如果点击此按钮就会尝试从“sorter-staet.bin”文件加载保存的排序状态，并加载。然后显示数据来源的下拉菜单，如果选择随机生成还会显示文本框提示数据数据量大小，如果时选择从文件中加载那么尝试自动加载名为“input.txt”的文件内的数据。</p><p>me: main_view_t 类型的结构体地址</p><p>x, y, w, h: 在坐标(x,y)处显示，长宽分别是w, h英寸</p><p>返回值：控件下边界的y坐标</p><p><code>static void control_buttons_display(main_view_t *me, double x, double y, double w, double h);</code></p><p>显示减速、加速、下一步和速度值的按钮。</p><p>me: main_view_t 类型的结构体地址</p><p>x, y, w, h: 在坐标(x,y)处显示，长宽分别是w, h英寸</p><p><code>static int double_less(void const *a, void const *b);</code></p><p>给qsort函数使用的回调函数，返回 a – b的值，用于按照从小到大排序</p><p>a：指向第一个数的地址</p><p>b：指向第二个数的地址</p><p>返回值：&lt;0：a &lt; b</p><p>​     0：a == b</p><p>​    &gt;0：a &gt; b</p><p><code>static int double_great(void const *a, void const *b);</code></p><p>同 int_less，只是此函数按照从大到小排序，等价于调用 int_less(b, a)</p><p><code>static bool generate_nums(main_view_t *me);</code></p><p>根据me-&gt;alg_idx决定生成什么类型的数据，如果时DATASRC_RANDOM则调用random_nums(0, 4*size, size)生成me中指定数据量为size的数据，如果为DATASRC_ASCEND或DATASRC_DESCEND再调用qsort()对数据排序；如果是DATASRC_LOADFILE，那么使用load_nums()从文件“input.txt”中加载数据，然后使用sorter_set_nums()给排序算法添加数据。</p><p>me: main_view_t类型的结构体指针</p><p>返回值：true：操作成功</p><p>​    false：操作失败</p><h3 id="about-view-c中函数的说明：">about-view.c中函数的说明：</h3><p><code>static void display(view_t *me);</code></p><p>和main-view.c中的display类似，显示关于视图到屏幕上，具体显示的内容为作者列表。</p><p>me: about_view_t结构体内base成员的地址</p><p><code> view_t *about_view_create(void);</code></p><p>和main_view_create类似，只是给destroy成员赋值为VIEW_DESTROY_DFT，表明不需要特殊的释放内存方式，使用view_t内部默认的释放内存方式即可。</p><p>返回值： about_view_t 结构体成员base的地址</p><h3 id="sorter-c中函数的说明：">sorter.c中函数的说明：</h3><p><code>void sorter_update(sorter_t *me);</code></p><p>如果当前排序状态不是SORTER_SORTING，直接返回。</p><p>让me-&gt;frame_cnt加一，如果frame_cnt乘以帧与帧之间间隔的时间大于等于1000除以速度时，调用me-&gt;next_step(me)更新到下一步。</p><p>me: 排序算法结构体指针</p><p><code>void sorter_speed_ctl(sorter_t *me, bool inc);</code></p><p>如果inc为真，增加速度最大值时SPEED_MAX(50)，如果inc为假，减少速度值，最小值为SPEED_MIN。</p><p>me: 排序算法结构体指针</p><p>inc: true增加速度，false减少速度</p><p><code>sorter_t *sorter_construct(sorter_t *me);</code></p><p>初始化me结构体的成员，包括设置速度为默认值SPEED_DFT、frame_cnt为0，状态为SORTER_UNREADY、排序按照升序排序等。</p><p>me: 排序算法结构体指针</p><p>返回值：me</p><p><code>sorter_t *sorter_load_from(sorter_t *me, FILE *istream);</code></p><p>从文件输入流istream中读取数据并解析校验通过后，给me结构体进行初始化。首先读取被排序的元素的个数size，然后依次读取已经被部分排序的素组和原始数据的数组，然后再读取速度speed、帧计数frame_cnt、状态state、升序与否ascend，之后计算出最大值和最小值给me初始化。整个过程成功返回me，失败返回空指针。</p><p>me: 排序算法结构体指针</p><p>istream: 包含有待待解析的数据的输入流</p><p>返回值：me：读取并初始化成功</p><p>NULL：读取或者初始化失败</p><p><code>void sorter_deconstruct(sorter_t *me);</code></p><p>释放me结构体中nums和nums_back的空间。</p><p><code>bool sorter_set_nums(sorter_t *me, double *nums, int size, int type);</code></p><p>为排序算法设置数据，包括数据量大小和数据类型，设置当前数据的备份，采取的是从nums复制数据到me-&gt;nums和me-&gt;nums_back，并求出最大值最小值。</p><p>me: 排序算法结构体</p><p>nums, size: 输入的数据</p><p>type: 输入数据的类型</p><p>返回值：true: 设置成功</p><p>​    false: 设置失败</p><p><code>void sorter_restart(sorter_t *me);</code></p><p>重置排序算法的状态，包括从nums_back复制数据到nums数组，frame_cnt设置为0，状态为SORTER_READY</p><p>me: 排序算法结构体指针</p><p><code> void sorter_display_unready(double x, double y, double w, double h);</code></p><p>在起点为x, y宽高分别是w, h的区域显示数据没有准备好的提示</p><p>x, y: 区域起始坐标，单位英寸</p><p>w, h: 区域宽高，单位英寸</p><p><code>bool sorter_save_state_at(sorter_t *me, FILE *ostream);</code></p><p>格式sorter_t类型的结构体me到输出流ostream中，此格式可以被sorter_load_from()函数解析用以还原此结构体。</p><p>me: 排序算法结构体</p><p>ostream: 输出流</p><p>返回值：true：格式化输出成功</p><p>​    false：格式化输出失败</p><h3 id="bubble-sorter-c中函数的说明：">bubble-sorter.c中函数的说明：</h3><p><code>static void next_step(sorter_t *b);</code></p><p>冒泡排序执行下一步操作。具体来说，当排序算法没有处于SORTER_SORTING或者SORTER_PAUSED状态时，直接返回。设置frame_cnt为0，根据冒泡排序过程比较nums[i]和nums[i+1]的大小，当nums[i]&gt;nums[i+1]和ascned同时为真（升序排序），或者同时为假时（降序排序）交换nums[i]和nums[i+1]。然后me-&gt;i加一，完成冒泡排序的一步。</p><p>b: 冒泡排序成员base的地址</p><p><code>static void display(sorter_t *b);</code></p><p>如果状态是SORTER_UNREADY时，调用sorter_display_unready()函数并返回。然后按照柱状图形式可视化当前排序的状态，对于已经排好序的数据绘制为深灰色Dark Gray，对于未排好序的数据绘制为浅灰色Light Gray，当前排序进行到的数据绘制为橘黄色Orange，同时如果数据量过多导致柱宽度小于0.05那么不绘制边框。</p><p>b: 冒泡排序成员base的地址</p><p><code>static void restart(sorter_t *b);</code></p><p>调用 sorter_restart(b)，然后设置i和k为0，以表示重新排序。</p><p>b: 冒泡排序成员base的地址</p><p><code>static void destroy(sorter_t *b);</code></p><p>释放内存，通过container_of计算出包含b的结构体起始地址然后调用free()释放内存。</p><p>b: 冒泡排序成员base的地址</p><p><code>static bool save_state(sorter_t *b, char const *ofile);</code></p><p>保存冒泡排序的状态到文件 ofile 里。具体来说，首先调用 sorter_save_state_at() 存储sorter_t结构体信息到文件里，然后存储i和k到文件里。</p><p>b: b: 冒泡排序成员base的地址</p><p>ofile: 输出到的文件名</p><p>返回值：true：存储成功，false：存储失败</p><p><code>sorter_t *bubble_sorter_create(void);</code></p><p>同main_view_create()类似，分配一个bubble_sort_t结构体，并初始化成员，然后返回成员base的地址</p><p>返回值：成员base的地址，类型是sorter_t</p><p><code>sorter_t *bubble_sorter_load(char const *state_file);</code></p><p>从文件 state_file 中读取、解析并初始化一个 bubble_sorter_t 的结构体，然后返回其结构体内部 base 成员的地址。冒泡排序文件格式，第一行是“!!bubble sort state file!!”，然后是 sorter_t 结构体保存到文件的数据，然后是bubble_sorter_t结构体中i和k的值。</p><p>state_file：状态文件</p><p>返回值：成员base的地址，类型是sorter_t</p><p>quick-sorter.c中函数的说明，quick-sorter中的这些函数名字和bubble-sorter中名字类似，功能也是一致的，只是实现细节和排序算法相关：</p><p><code>static void next_step(sorter_t *b);</code></p><p>由于快速排序的复杂性，这个函数是快速排序模块最为复杂的函数，相当于把递归的快速排序用非递归来实现，同时又把其成一步步运行的状态。函数内部定义了两个宏push和pop用于操作栈，整个排序过程分为了多个内部状态QUICK_INIT初始状态，处于这个状态只把0和size-1这个区间压入栈，然后进入 QUICK_SORT1，这个状态首先判断栈是不是为空，如果是那么排序完成，否则弹出元素，并进入状态QUICK_PIVOT，准备根据枢纽元划分区间，此状态选择区间最右边元素作为枢纽元设置me-&gt;pivot_idx为r，然后进入QUICK_PARTITION_LO状态，移动l指针一步，然后保持这个状态，直到多次调用next_step使得l和r交错或者nums[l]大于nums[pivot_idx]进入QUICK_PARTITION_HI以便移动h指针，类似减少h指针直到l和r交错或者nums[h]小于nums[pivot_idx]，然后进入状态QUICK_SWAP，如果l和r交错那么进入QUICK_PARTITION_END状态，否则交换nums[l]和nums[r]然后继续进入QUICK_PARTITION_LO状态进行划分；处于QUICK_PARTITION_END状态时，把枢纽元交换到nums[l]处，然后进入压入当前区间的状态QUICK_PUSH_SEGMENT，处于此状态添加枢纽元下标到done_list中，然后更具lo和pivot_idx以及pivot_idx和hi的关于决定是否把左半区间压入栈或者把右半区间压入栈，然后状态进入QUICK_SORT1开始继续处理。</p><p>b: 快速排序结构体成员base的地址</p><p><code>static void display(sorter_t *b);</code></p><p>和冒泡排序算法的display()类似，对排序好的数据绘制为深灰色，未排序好的数据为浅灰色，当前活动的数据为橘黄色，此外还增加了绘制枢纽元颜色为棕色Brown，绘制枢纽元高度的水平线，绘制当前活动区间的两条竖线，如果正在交互两个元素，这两个元素为红色以展示交换过程。</p><p>b: 快速排序结构体成员base的地址</p><p><code>static void restart(sorter_t *b);</code></p><p>重置快速排序过程，调用sorter_restart(b)然后重置stack_size为0，done_size 为0，pivot_idx 为-1，状态为QUICK_INIT状态。</p><p>b: 快速排序结构体成员base的地址</p><p><code>static void destroy(sorter_t *b);</code></p><p>和冒泡排序的destroy函数功能完全一样，只是释放内存。</p><p>b: 快速排序结构体成员base的地址</p><p><code>static bool save_state(sorter_t *b, char const *ofile);</code></p><p>保存快速排序算法的状态到文件ofile。类似于bubble-sorter.c中的save_state一样。第一行输出“!!quick sort state file!!”，然后调用sorter_save_state_at()保存成员变量base的状态，之后输出stack_size和栈的所有数据；输出done_size和done_list数组的值，输出状态state，lo, hi, l, r和pivot_idx的值。</p><p>b: 快速排序结构体成员base的地址</p><p>ofile: 存储状态的文件</p><p>返回值：true: 保存成功，false：保存失败</p><p><code>sorter_t *quick_sorter_create(void);</code></p><p>分配quick_sort_t类型结构体，并初始化。包括设置base成员的各个函数指针以及stack_size设置为0，done_size设置为0，pivot_idx为-1，状态为QUICK_INIT</p><p>返回值： 快速排序结构体成员base的地址，如果分配内存失败返回NULL</p><p><code>sorter_t *quick_sorter_load(char const *state_file);</code></p><p>从状态文件中读取数据并初始化快速排序结构体 quick_sorter_t。具体来说，首先读取第一行判断是不是为“!!quick sort state file!!”，成功的话继续使用 sorter_load_from()从文件流中继续读取数据并初始化base成员，之后继续读取stack_size和栈的数据，读取done_size和done_list数组的数据，读取状态state，读取lo, hi, l, r和pivot_idx的值。</p><p>state_file：状态文件名</p><p>返回值：初始化好的快速排序结构体内部base成员的地址；如果加载或初始化失败返回NULL</p><h3 id="select-sorter-c中函数的说明：">select-sorter.c中函数的说明：</h3><p><code>static void next_step(sorter_t *b);</code></p><p>选择排序执行下一步操作。具体来说，当排序算法没有处于SORTER_SORTING或者SORTER_PAUSED状态时，直接返回。设置frame_cnt为0。根据选择排序过程，比较nums[max]和nums[i]的大小，如果nums[max]小于nums[i]且排序方式为升序的话，则把i赋值给max。一轮过后交换max和i的值。</p><p>b: 选择排序成员base的地址</p><p><code>static void display(sorter_t *b);</code></p><p>如果状态是SORTER_UNREADY时，调用sorter_display_unready()函数并返回。然后按照柱状图形式可视化当前排序的状态，对于已经排好序的数据绘制为深灰色Dark Gray，对于未排好序的数据绘制为浅灰色Light Gray，当前排序进行到的数据绘制为橘黄色Orange，当前的最值数据绘制为红色Red,同时如果数据量过多导致柱宽度小于0.05那么不绘制边框。</p><p>b: 选择排序成员base的地址</p><p><code>static void restart(sorter_t *b);</code></p><p>调用 sorter_restart(b)，然后设置i和k为0，以表示重新排序。</p><p>b: 选择排序成员base的地址</p><p><code>static void destroy(sorter_t *b);</code></p><p>释放内存，通过container_of计算出包含b的结构体起始地址然后调用free()释放内存。</p><p>b: 选择排序成员base的地址</p><p><code>static bool save_state(sorter_t *b, char const *ofile);</code></p><p>保存选择排序的状态到文件 ofile 里。具体来说，首先调用 sorter_save_state_at() 存储sorter_t结构体信息到文件里，然后存储i、max和k到文件里。</p><p>b: b: 选择排序成员base的地址</p><p>ofile: 输出到的文件名</p><p>返回值：true：存储成功，false：存储失败</p><p><code>sorter_t *select_sorter_create(void);</code></p><p>同main_view_create()类似，分配一个select_sort_t结构体，并初始化成员，然后返回成员base的地址</p><p>返回值：成员base的地址，类型是sorter_t</p><p><code>sorter_t *select_sorter_load(char const *state_file);</code></p><p>从文件 state_file 中读取、解析并初始化一个 select_sorter_t 的结构体，然后返回其结构体内部 base 成员的地址。选择排序文件格式，第一行是“!!select sort state file!!”，然后是 sorter_t 结构体保存到文件的数据，然后是select_sorter_t结构体中i和k以及max的值。</p><p>state_file：状态文件</p><p>返回值：成员base的地址，类型是sorter_t</p><h3 id="merge-sorter-c中函数的说明：">merge-sorter.c中函数的说明：</h3><p><code>static void next_step(sorter_t *b);</code></p><p>该函数实现归并排序执行下一步操作的功能，利用非递归的方式实现递归的归并排序算法，使之能够单步进行。具体而言，当排序算法不处于SORTER_SORTING或者SORTER_PAUSED状态时，直接返回，反之继续，并设置frame_cnt为0。该函数将整个排序过程分为三个内部状态：MERGE_STEP1、MERGE_STEP2、MERGE_STEP3。处于MERGE_STEP1时，函数首先判断排序是否完成，若未完成，则利用while循环找出本次需要排序的子列（子列本身未完成排序，但其前后两部分均已完成排序），然后进入MERGE_STEP2。处于MERGE_STEP2时，函数将需要排序的子列分为前后两个部分，并依序比较两部分中各元素大小，将比较结果储存至me-&gt;doing_list[]中，然后进入MERGE_STEP3。在MERGE_STEP3状态下，函数将me-&gt;doing_list[]中的元素赋值给nums[]中的对应子列，最后重新进入MERGE_STEP1状态寻找下一个需要排序的子列。至此该函数已完成一次子列排序，之后函数将重复这三个过程，直到排序完成。</p><p>b: 归并排序结构体成员base的地址</p><p><code>static void display(sorter_t *b);</code></p><p>如果状态是SORTER_UNREADY时，调用sorter_display_unready()函数并返回，反之继续。该函数以柱状图的形式可视化当前排序状态，其将绘图区域分为上下两部分，上半部分绘制me-&gt;doing_list[]中的数据，下半部分绘制nums[]中的数据。对于已经排序过的数据绘制为深灰色Dark Gray，对于未排序过的数据绘制为浅灰色Light Gray，对于正在排序的数据绘制为橘黄色Orange，对于正在进行比较的数据， 分别绘制为红色Red和绿色Green。同时如果数据量过多导致柱宽度小于0.05那么不绘制边框。</p><p>b: 归并排序成员base的地址</p><p><code>static void restart(sorter_t *b);</code></p><p>重置归并排序过程，调用sorter_restart(b)然后重置i、j、k为0，状态为MERGE_STEP1状态。</p><p>b: 归并排序结构体成员base的地址</p><p><code>static void destroy(sorter_t *b);</code></p><p>和冒泡排序的destroy函数功能完全一样，只是释放内存。</p><p>b: 归并排序结构体成员base的地址</p><p><code>static int Check(double Arr[],int StartIndex, int EndIndex, bool flag);</code></p><p>检查输入数组是否已完成排序。</p><p>返回值：1：已完成排序；0：未完成排序</p><p><code>static bool save_state(sorter_t *b, char const *ofile);</code></p><p>保存归并排序算法的状态到文件ofile。类似于bubble-sorter.c中的save_state一样。第一行输出“!!merge sort state file!!”，然后调用sorter_save_state_at()保存成员变量base的状态，之后输出状态state；输出start，end，mid的值；输出doing_list数组的值；输出i，j，k的值。</p><p>b: 归并排序结构体成员base的地址</p><p>ofile: 存储状态的文件</p><p>返回值：true: 保存成功，false：保存失败</p><p><code>sorter_t *merge_sorter_create(void);</code></p><p>分配merge_sort_t类型结构体，并初始化。包括设置base成员的各个函数指针以及i，j，k设置为0，state设置为MERGE_STEP1</p><p>返回值： 归并排序结构体成员base的地址，如果分配内存失败返回NULL</p><p><code>sorter_t *merge_sorter_load(char const *state_file);</code></p><p>从状态文件中读取数据并初始化归并排序结构体 merge_sorter_t。具体来说，首先读取第一行判断是不是为“!!merge sort state file!!”，成功的话继续使用 sorter_load_from()从文件流中继续读取数据并初始化base成员，之后继续读取状态state，读取start，end，mid的值，读取doing_list数组的数据，读取i，j，k的值。</p><p>state_file：状态文件名</p><p>返回值：初始化好的归并排序结构体内部base成员的地址；如果加载或初始化失败返回NULL</p><h3 id="insertion-sorter-c中函数的说明：">insertion-sorter.c中函数的说明：</h3><p><code>static void next_step(sorter_t *b);</code></p><p>插入排序执行下一步操作。具体来说，当排序算法没有处于SORTER_SORTING或者SORTER_PAUSED状态时，直接返回，反之继续，并设置frame_cnt为0。排序过程分为3个内部状态：INSERTION_STEP1, INSERTION_STEP2, INSERTION_STEP3。处于INSERTION_STEP1时，其将nums[i]的值赋值给doing_list[i]，并进入INSERTION_STEP2。在INSERTION_STEP1状态中，函数将待排序数据（doing_list[k]）与相邻数据(nums[k-1]])进行比较，若顺序有误，则交换数据，以此来确定待排序数据的位置，然后进入INSERTION_STEP3。在INSERTION_STEP1状态下，函数将doing_list[k]的值赋值给nums[k]。重复上述三个状态，直到所有元素完成排序</p><p>b: 插入排序结构体成员base的地址</p><p><code>static void display(sorter_t *b);</code></p><p>如果状态是SORTER_UNREADY时，调用sorter_display_unready()函数并返回，反之继续。该函数以柱状图的形式可视化当前排序状态，其将绘图区域分为上下两部分，上半部分绘制me-&gt;doing_list[]中的数据，下半部分绘制nums[]中的数据。对于未排序过的数据绘制为浅灰色Light Gray，对于正在排序的数据绘制为橘黄色Orange，对于正在进行比较的数据， 分别绘制为红色Red和绿色Green，排序完成后数据绘制为深灰色Dark Gray。同时如果数据量过多导致柱宽度小于0.05那么不绘制边框。</p><p>b: 插入排序成员base的地址</p><p><code>static void restart(sorter_t *b);</code></p><p>重置插入排序过程，调用sorter_restart(b)然后重置i，k为0，flag为0，状态为INSERTION_STEP1状态。</p><p>b: 插入排序结构体成员base的地址</p><p><code>static void destroy(sorter_t *b);</code></p><p>释放内存，通过container_of计算出包含b的结构体起始地址然后调用free()释放内存。</p><p>b: 插入排序结构体成员base的地址</p><p><code>static bool save_state(sorter_t *b, char const *ofile);</code></p><p>保存快速排序算法的状态到文件ofile。类似于bubble-sorter.c中的save_state一样。第一行输出“!!insertion sort state file!!”，然后调用sorter_save_state_at()保存成员变量base的状态，之后输出i，k的值；输出doing_list数组的值，输出状态state，flag的值。</p><p>b: 插入排序结构体成员base的地址</p><p>ofile: 存储状态的文件</p><p>返回值：true: 保存成功，false：保存失败</p><p><code>sorter_t *insertion_sorter_create(void);</code></p><p>分配insertion_sort_t类型结构体，并初始化。包括设置base成员的各个函数指针以及i，k设置为0，flag设置为1，状态为INSERTION_STEP1</p><p>返回值： 插入排序结构体成员base的地址，如果分配内存失败返回NULL</p><p><code>sorter_t *insertion_sorter_load(char const *state_file);</code></p><p>从状态文件中读取数据并初始化插入排序结构体 insertion_sorter_t。具体来说，首先读取第一行判断是不是为“!!insertion sort state file!!”，成功的话继续使用 sorter_load_from()从文件流中继续读取数据并初始化base成员，之后继续读取i，k的值，读取doing_list数组的数据，读取状态state，读取flag的值。</p><p>state_file：状态文件名</p><p>返回值：初始化好的插入排序结构体内部base成员的地址；如果加载或初始化失败返回NULL</p><h3 id="utility-h中宏的说明：">utility.h中宏的说明：</h3><p><code>ARRAY_SIZE(arr)</code></p><p>求出数组元素个数，使用 sizeof(arr) 求出数组占的内存大小，除以sizeof(arr[0])一个元素占的大小，得出有多少个元素</p><p><code>container_of(ptr, type, member)</code></p><p>根据type类型中member成员的地址求出type类型的地址，具体就是ptr地址减去member在type类型中的偏移量使用 ptr – offset(type, member)来求出</p><h3 id="utility-c中函数的说明：">utility.c中函数的说明：</h3><p><code>double min_nums(double const *nums, int size);</code></p><p>求出数组中的最小值</p><p>nums, size: 用于表示数组</p><p>返回值：最小值</p><p><code>double max_nums(double const *nums, int size);</code></p><p>类似double min_nums(); 只是返回的是最大值</p><p><code>static int random_int(int lo, int hi);</code></p><p>使用公式 rand()/(double)RAND_MAX * (1+hi – lo) + lo生成[lo, hi]区间的随机整数</p><p>lo, hi: 生成的随机数最小值和最大值</p><p>返回值：生成的随机数</p><p><code>double *random_nums(int lo, int hi, int size);</code></p><p>反复调用random_int(lo, hi) 生成size个随机整数并放到动态分配内存的数组里。</p><p>lo, hi: 生成随机整数的最小值和最大值</p><p>size: 生成的个数</p><p>返回值：含有size个随机整数的数组</p><p><code>double *load_nums(char const *name, int *size, int *ptype);</code></p><p>从名为name的文件里读取数据，然会数据数组的地址并把数据大小和数据类型分别存到size指针和ptype里，具体来说首先打开文件name为输入流 istream，然后简介调用load_nums_from()完成具体解析操作。数据文件里数据格式为课程文档中规定的格式。</p><p>name: 文件名</p><p>size: 指向存储数据大小的指针</p><p>返回值：动态分配的数组的起始地址，如果加载失败返回NULL</p><p><code>double *load_nums_from(FILE *istream, int *psize, int *type);</code></p><p>从文件流中读取并解析数据，首先读取一个字符串判断是否是int、float和double中之一，相应给type设置为SORTER_INT、SORTER_FLOAT、SORTER_DOUBLE，紧接着根据类型读取数据，直到读取数据结束，设置psize的值为读取的数据个数。然后返回数组。</p><p>istream: 输入流</p><p>psize: 存储文件大小的地址</p><p>type: 存储文件类型的地址</p><p>返回值：NULL读取失败；读取成功返回数组地址</p><p><code>bool save_nums_at(FILE *ostream, double const *nums, int size, int type)</code></p><p>把地址时nums大小为size的数组的数字存入流ostream中。首先根据type决定输出int、float还是double字符串，紧接着输出nums中的数并按照空格隔开。</p><p>ostream: 输出流</p><p>nums: 数组地址</p><p>size: 数组大小</p><p>type: 数据类型</p><p>返回值：true写入成功，false写入失败</p><p><code>bool save_nums(char const *ofile, double const *nums, int size, int type);</code></p><p>存储数据到文件，内部首先打开文件为输出流ostream，然后调用save_nums_at()实现真正的存储操作。</p><p>ofile: 输出保存的文件名</p><p>nums, size：输出的数据</p><p>type: 数据的类型</p><p>返回值：true 存储成功，false 存储失败</p>]]></content>
      
      
      <categories>
          
          <category> 大作业 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 可视化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《算法笔记》第六章</title>
      <link href="2021/03/11/%E3%80%8A%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0%E3%80%8B%E7%AC%AC%E5%85%AD%E7%AB%A0/"/>
      <url>2021/03/11/%E3%80%8A%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0%E3%80%8B%E7%AC%AC%E5%85%AD%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<h1>《算法笔记》第六章</h1><h2 id="vector">vector</h2><p>vector是向量，可以理解成“变长数组”，使用前需要添加下列语句</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br></pre></td></tr></table></figure><h3 id="定义">定义</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="keyword">typename</span>&gt; name;<span class="comment">//单独定义</span></span><br><span class="line">vector&lt;<span class="keyword">typename</span>&gt; Arrayname[arraySize];<span class="comment">//定义数组，相当于二元数组，这样定义的一维长度是固定的</span></span><br><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt; &gt; name;<span class="comment">//定义二维数组，二维均是变长的</span></span><br></pre></td></tr></table></figure><h3 id="访问">访问</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name[index]<span class="comment">//下标访问</span></span><br></pre></td></tr></table></figure><h3 id="函数">函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">push_back</span>(i);<span class="comment">//在vi后面添加i</span></span><br><span class="line"><span class="built_in">pop_back</span>();<span class="comment">//删除末尾元素</span></span><br><span class="line"><span class="built_in">size</span>()<span class="comment">//获取vector个数</span></span><br><span class="line"><span class="built_in">clear</span>();<span class="comment">//清空vector</span></span><br><span class="line"><span class="built_in">begin</span>()<span class="comment">//首元素地址</span></span><br><span class="line"><span class="built_in">end</span>()<span class="comment">//尾元素的下一个地址</span></span><br><span class="line"><span class="built_in">insert</span>(it,x);<span class="comment">//在it处添加元素x</span></span><br><span class="line"><span class="built_in">erase</span>(it);<span class="comment">//删除it处的元素</span></span><br><span class="line"><span class="built_in">erase</span>(first.last);<span class="comment">//删除[first,last)的所有元素</span></span><br></pre></td></tr></table></figure><h3 id="迭代器">迭代器</h3><p>可以理解成指针</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vector &lt;<span class="keyword">typename</span>&gt;::iterator it=vi.<span class="built_in">begin</span>();<span class="comment">//定义迭代器it指向首元素地址，此时*it就代表了vi的首元素</span></span><br></pre></td></tr></table></figure><h2 id="set">set</h2><p>set是集合，<strong>自动递增</strong>排序，元素互不重复，使用前需要添加头文件</p><p>可以用来去重并升序排序</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br></pre></td></tr></table></figure><h3 id="定义-2">定义</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set &lt;<span class="keyword">typename</span>&gt; name;<span class="comment">//单独定义</span></span><br><span class="line">set&lt;<span class="keyword">typename</span>&gt; Arrayname[arraySize];<span class="comment">//定义数组，数组中每一个都是set容器</span></span><br></pre></td></tr></table></figure><h3 id="访问-2">访问</h3><p>set只能用迭代器访问</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set&lt;<span class="keyword">typename</span>&gt;::iterator it;<span class="comment">//可以通过*it访问，但不能用*(it+i)</span></span><br></pre></td></tr></table></figure><h3 id="函数-2">函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">insert</span>(x);<span class="comment">//插入x</span></span><br><span class="line"><span class="built_in">find</span>(value);<span class="comment">//返回值为value的迭代器</span></span><br><span class="line"><span class="built_in">erase</span>(it);<span class="comment">//删除迭代器为it的元素</span></span><br><span class="line"><span class="built_in">erase</span>(value);<span class="comment">//删除值为value的元素</span></span><br><span class="line"><span class="built_in">erase</span>(first,last);<span class="comment">//删除[first,last)区间的元素</span></span><br><span class="line"><span class="built_in">clear</span>();<span class="comment">//清空所有元素</span></span><br></pre></td></tr></table></figure><h2 id="string">string</h2><p>字符串，使用前需添加头文件</p><p>字符串可以直接通过加法拼接，直接比较大小（字典序）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span>  <span class="keyword">namespace</span> std;</span><br></pre></td></tr></table></figure><h2 id="定义-3">定义</h2><p><code>string str=&quot;abc&quot;;</code></p><h2 id="访问-3">访问</h2><p><code>str[i]</code></p><p>输入输出只能用cin和cout</p><h3 id="迭代器-2">迭代器</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string::iterator it;</span><br></pre></td></tr></table></figure><p>string迭代器支持直接加减某个数字</p><h3 id="函数-3">函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">length</span>()<span class="comment">//返回str的长度，即存放的字符数</span></span><br><span class="line"><span class="built_in">insert</span>(pos,string);<span class="comment">//在pos的位置插入字符串string</span></span><br><span class="line"><span class="built_in">insert</span>(it,it2,it3);<span class="comment">//在it的位置插入字符串[it2,it3)</span></span><br><span class="line"><span class="built_in">erase</span>(it);<span class="comment">//删除迭代器为it的元素</span></span><br><span class="line"><span class="built_in">erase</span>(first,last);<span class="comment">//删除[first,last)区间的元素</span></span><br><span class="line"><span class="built_in">erase</span>(pos,length):<span class="comment">//删除从pos开始的length个字符</span></span><br><span class="line"><span class="built_in">clear</span>();<span class="comment">//清空字符串</span></span><br><span class="line"><span class="built_in">substr</span>(pos,len)<span class="comment">//返回从pos开始长度为len的子串</span></span><br><span class="line"><span class="built_in">find</span>(str2)<span class="comment">//若str2为子串，返回第一次出现的位置，如果不是，返回string::npos</span></span><br><span class="line"><span class="built_in">replace</span>(pos,len,str2);<span class="comment">//把从pos开始长度为len的子串替换为str2</span></span><br><span class="line"><span class="built_in">replace</span>(it1,it2,str2);<span class="comment">//把[it1,it2)替换为str2</span></span><br></pre></td></tr></table></figure><h2 id="map">map</h2><p>map可以将基本类型映射到基本类型，基本类型也可以是STL容器，使用前需添加头文件</p><p>可以用来建立字符（串）与整数之间的联系，判断大整数或者其他类型是否存在的题目，把map当bool数组用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br></pre></td></tr></table></figure><h3 id="定义-4">定义</h3><p>如果是字符串到整数的映射必须使用string而不是char</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map&lt;typename1,typename2&gt; mp;</span><br></pre></td></tr></table></figure><h3 id="访问-4">访问</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mp[type1]<span class="comment">//相当于mp[type2]</span></span><br></pre></td></tr></table></figure><h3 id="迭代器-3">迭代器</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">map&lt;typename1，typename2&gt;::iterator it;</span><br><span class="line">it -&gt;first<span class="comment">//当前映射的键</span></span><br><span class="line">it -&gt;second<span class="comment">//当前映射的值</span></span><br></pre></td></tr></table></figure><h3 id="函数-4">函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">find</span>(key)<span class="comment">//返回键为key的迭代器</span></span><br><span class="line"><span class="built_in">erase</span>(it);<span class="comment">//删除迭代器为it的元素</span></span><br><span class="line"><span class="built_in">erase</span>(key);<span class="comment">//删除键为key的元素</span></span><br><span class="line"><span class="built_in">erase</span>(first,last);<span class="comment">//删除迭代器为[first,last)的元素</span></span><br><span class="line"><span class="built_in">size</span>()<span class="comment">//映射的对数</span></span><br><span class="line"><span class="built_in">clear</span>();<span class="comment">//清空</span></span><br></pre></td></tr></table></figure><h2 id="queue">queue</h2><p>队列，使用前需添加头文件</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br></pre></td></tr></table></figure><h3 id="定义-5">定义</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">queue &lt;<span class="keyword">typename</span>&gt; name;</span><br></pre></td></tr></table></figure><h3 id="访问-5">访问</h3><p>使用front和back之前要先用empty判断一下队列是否为空</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">front</span>()<span class="comment">//队首元素</span></span><br><span class="line"><span class="built_in">back</span>()<span class="comment">//队尾元素</span></span><br></pre></td></tr></table></figure><h3 id="函数-5">函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">push</span>(x);<span class="comment">//将x入队</span></span><br><span class="line"><span class="built_in">pop</span>();<span class="comment">//令首元素出列</span></span><br><span class="line"><span class="built_in">empty</span>()<span class="comment">//检测queue是否为空，返回true则空，返回false则空</span></span><br><span class="line"><span class="built_in">size</span>()<span class="comment">//队列元素个数</span></span><br></pre></td></tr></table></figure><h2 id="priority-queue">priority_queue</h2><p>优先队列</p><h3 id="定义-6">定义</h3><p>先添加和queue一样的头文件</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">priority_queue&lt;<span class="keyword">typename</span>&gt;name;</span><br></pre></td></tr></table></figure><h3 id="访问-6">访问</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">top</span>()<span class="comment">//访问优先级最高的元素</span></span><br></pre></td></tr></table></figure><h3 id="函数-6">函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">push</span>(x);<span class="comment">//将x入队</span></span><br><span class="line"><span class="built_in">pop</span>();<span class="comment">//令队首元素出队</span></span><br><span class="line"><span class="built_in">empty</span>()<span class="comment">//检测queue是否为空，返回true则空，返回false则非空</span></span><br><span class="line"><span class="built_in">size</span>()<span class="comment">//队列元素个数</span></span><br></pre></td></tr></table></figure><h3 id="优先级">优先级</h3><h4 id="基本数据类型">基本数据类型</h4><p>一般是数字大的优先级高，定义如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">priority_queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">priority_queue&lt;<span class="keyword">int</span>,vector&lt;<span class="keyword">int</span>&gt;,less&lt;<span class="keyword">int</span>&gt;&gt; q;<span class="comment">//两者等价</span></span><br></pre></td></tr></table></figure><p>想让数字小的优先级大只需</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">priority_queue&lt;<span class="keyword">int</span>,vector&lt;<span class="keyword">int</span>&gt;,greater&lt;<span class="keyword">int</span>&gt;&gt; q;</span><br></pre></td></tr></table></figure><h4 id="结构体类型">结构体类型</h4><p>在结构体里面重载小于号即可</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fruit</span>&#123;</span></span><br><span class="line">  string name;</span><br><span class="line">  <span class="keyword">int</span> price;</span><br><span class="line">  <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (fruit f1,fruit f2)&#123;</span><br><span class="line">    <span class="keyword">return</span> f1.price &lt; f2.price;<span class="comment">//把小于号改成大于号就反一下</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这样之后f1&lt;f2就等价于f1.price&lt;f2.price</p><p>再定义fruit类型的优先队列，内部就是以价格高的水果为优先级高</p><p>也可以把重载函数写在结构体外面</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cmp</span>&#123;</span></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">operator</span> <span class="params">()</span> <span class="params">(fruit f1, fruit f2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> f1.price&gt;f2.price;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">priority_queue&lt;fruit, vector&lt;fruit&gt;, cmp&gt; q;<span class="comment">//定义</span></span><br></pre></td></tr></table></figure><h2 id="stack">stack</h2><p>栈，后进先出的容器，使用前需加上头文件</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">stack&lt;<span class="keyword">typename</span>&gt; name;<span class="comment">//定义</span></span><br></pre></td></tr></table></figure><h3 id="访问-7">访问</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">top</span>()<span class="comment">//访问栈顶元素</span></span><br></pre></td></tr></table></figure><h3 id="函数-7">函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">push</span>(x);<span class="comment">//将x入栈</span></span><br><span class="line"><span class="built_in">pop</span>();<span class="comment">//弹出栈顶元素</span></span><br><span class="line"><span class="built_in">empty</span>()<span class="comment">//返回true则空，返回false则非空</span></span><br><span class="line"><span class="built_in">size</span>()<span class="comment">//返回元素个数</span></span><br></pre></td></tr></table></figure><h3 id="pair">pair</h3><p>把两个元素绑在一起作为一个合成元素，可以看成有两个元素的结构体</p><h3 id="定义-7">定义</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span><span class="comment">//添加map头文件后会自动添加utility</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function">pair&lt;typename1,typename2&gt; <span class="title">name</span><span class="params">(value1,value2)</span></span>;<span class="comment">//value为初始化元素</span></span><br></pre></td></tr></table></figure><h3 id="访问-8">访问</h3><figure class="highlight c"><figcaption><span>++</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">pair</span>.first<span class="comment">//访问第一个元素</span></span><br><span class="line"><span class="built_in">pair</span>.second<span class="comment">//访问第二个元素</span></span><br></pre></td></tr></table></figure><h3 id="比较">比较</h3><p>两个pair类型比较是先比较first再比较second</p><h2 id="algorithm">algorithm</h2><p>使用前需添加头文件</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="built_in">max</span>(x,y)<span class="comment">//返回较大值</span></span><br><span class="line"><span class="built_in">min</span>(x.y)<span class="comment">//返回较小值</span></span><br><span class="line"><span class="built_in">abs</span>(x)<span class="comment">//返回绝对值</span></span><br><span class="line"><span class="built_in">swap</span>(x,y);<span class="comment">//交换x,y的值</span></span><br><span class="line"><span class="built_in">reverse</span>(it,it2);<span class="comment">//将[it,it2)的元素进行反转</span></span><br><span class="line"><span class="built_in">next_permutation</span>(序列);<span class="comment">//给出一个序列在全排列中的下一个序列</span></span><br><span class="line"><span class="built_in">fill</span>(区间,值);<span class="comment">//把某段区间赋为相同的某个值</span></span><br><span class="line"><span class="built_in">lower_bound</span>(first,last,val)<span class="comment">//寻找在[first,last)范围内第一个值大于等于val的位置，如果是数组则返回指针，如果是容器则返回迭代器，如果没有要寻找的元素则返回可以插入该元素的指针或迭代器</span></span><br><span class="line"><span class="built_in">upper_bound</span>(first,last,val)<span class="comment">//寻找在[first,last)范围内第一个值大于等于val的位置，如果是数组则返回指针，如果是容器则返回迭代器，如果没有要寻找的元素则返回可以插入该元素的指针或迭代器</span></span><br></pre></td></tr></table></figure><h3 id="sort">sort</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sort</span>(首元素地址，尾元素地址，比较函数（非必填）)；;<span class="comment">//默认从小到大排序</span></span><br></pre></td></tr></table></figure><p>如果需要从大到小，则需要使用比较函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bmp</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a&gt;b;<span class="comment">//当a大于b时把a放在b前面，即降序</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>STL容器中，只有vector，string，deque可以用sort</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《算法笔记》第五章</title>
      <link href="2021/02/28/%E3%80%8A%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0%E3%80%8B%E7%AC%AC%E4%BA%94%E7%AB%A0/"/>
      <url>2021/02/28/%E3%80%8A%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0%E3%80%8B%E7%AC%AC%E4%BA%94%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<h1>《算法笔记》第五章</h1><h2 id="最大公约数">最大公约数</h2><p>求最大公约数一般用辗转相除法，代码如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(b==<span class="number">0</span>)<span class="keyword">return</span> a;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">gcd</span>(b,a%b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最小公倍数">最小公倍数</h2><p>最小公倍数的求解要基于最大公约数</p><p>a和b的最大公约数为d，则最小公倍数为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi mathvariant="normal">/</mi><mi>d</mi><mo>∗</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">a/d*b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">a</span><span class="mord">/</span><span class="mord mathnormal">d</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">b</span></span></span></span></p><h2 id="分数">分数</h2><p>我们可以用一个结构体来表示分数，一般假分数比带分数用的多，所以只需要分子和分母两个变量即可。<strong>分数的计算可能会使分子或者分母超出int的范围，所以分数中的分子分母用long long来存储。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct <span class="title">Fraction</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> up,down;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而分子和分母当然不是任意的，需要满足以下规则</p><ol><li>如果分数为负，则分子为负</li><li>如果分数为0，则分子为0，分母为1</li><li>分子和分母没有除了1以外的公约数</li></ol><p>但很多时候我们会对分数进行运算，可能运算完就不满足上述的规则了，于是就需要一个函数来对分数进行化简</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Fraction <span class="title">reduction</span><span class="params">(Fraction result)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(result.down&lt;<span class="number">0</span>)&#123;</span><br><span class="line">    result.up=-result.up;</span><br><span class="line">    result.down=-result.down;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(result.up==<span class="number">0</span>)&#123;</span><br><span class="line">    result.down=<span class="number">1</span>;</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">int</span> d=<span class="built_in">gcd</span>(<span class="built_in">abs</span>(result.up),result.down);</span><br><span class="line">    result.up/=d;</span><br><span class="line">    result.down/=d;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="分数的计算">分数的计算</h3><h4 id="乘法">乘法</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Fraction <span class="title">multi</span><span class="params">(Fraction f1,Fraction f2)</span></span>&#123;</span><br><span class="line">  Fraction result;</span><br><span class="line">  result.up=f1.up*f2.up;</span><br><span class="line">  result.down=f1.down*f2.down;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">reduction</span>(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="除法">除法</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Fraction <span class="title">divide</span><span class="params">(Fraction f1,Fraction f2)</span></span>&#123;</span><br><span class="line">  Fraction result;</span><br><span class="line">  result.up=f1.up*f2.down;</span><br><span class="line">  result.down=f1.down*f2.up;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">reduction</span>(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="加法">加法</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Fraction <span class="title">multi</span><span class="params">(Fraction f1,Fraction f2)</span></span>&#123;</span><br><span class="line">  Fraction result;</span><br><span class="line">  result.up=f1.up*f2.down+f2.up*f2.down;<span class="comment">//减法此处换成减号即可</span></span><br><span class="line">  result.down=f1.down*f2.down;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">reduction</span>(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="分数的输出">分数的输出</h3><ol><li>输出前先化简</li><li>假分数输出时要转化为带分数</li><li>分母为1的分数转化为整数输出</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">showresult</span><span class="params">(Fraction r)</span></span>&#123;</span><br><span class="line">  r=<span class="built_in">reduction</span>(r);</span><br><span class="line">  <span class="keyword">if</span>(r.down==<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,r.up);&#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">abs</span>(r.up)&gt;r.down)&#123;<span class="comment">//注意这里要加绝对值</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %d/%d&quot;</span>,r.up/r.down,<span class="built_in">abs</span>(r.up)%r.down,r.down);</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d/%d&quot;</span>,r.up,r.down);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="素数">素数</h2><h3 id="素数的判断">素数的判断</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPrime</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(n&lt;=<span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">int</span> sqr=(<span class="keyword">int</span>)<span class="built_in">sqrt</span>(<span class="number">1.0</span>*n);<span class="comment">//sqrt的对象只能是浮点数所以先乘上1.0</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=sqr;i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(n%i==<span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="素数表">素数表</h3><p>因为素数的倍数一定不是素数，所以筛去这部分剩下的就是素数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=表长;</span><br><span class="line"><span class="keyword">bool</span> p[maxn]=&#123;<span class="number">0</span>&#125;;<span class="comment">//素数为false</span></span><br><span class="line"><span class="keyword">int</span> prime[maxn],pnum;<span class="comment">//存放素数，素数个数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">findprime</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;maxn;i++)&#123;<span class="comment">//注意i不能取maxn</span></span><br><span class="line">    <span class="keyword">if</span>(p[i]==<span class="literal">false</span>)&#123;</span><br><span class="line">      prime[pnum++]=i;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">2</span>*i;j&lt;maxn;j+=i)&#123;<span class="comment">//注意j不能取maxn</span></span><br><span class="line">        p[j]=<span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="质因式分解">质因式分解</h3><p>一个正整数n的质因子只有两种可能，一种一个大于sqrt其他小于，另一种所有质因子都小于sqrt。</p><p>所以只需先枚举小于sqrt的素数，判断是否是因子，然后将其除去，若除以所有因子后n仍大于1，则说明n还剩一个大于sqrt的因子。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">factor</span>&#123;</span></span><br><span class="line">  <span class="keyword">int</span> x,cnt;<span class="comment">//x为因子，cnt为个数</span></span><br><span class="line">&#125;fac[<span class="number">10</span>];<span class="comment">//10个足够应对int类型了</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(n==<span class="number">1</span>)<span class="built_in">printf</span>(<span class="string">&quot;1=1&quot;</span>);</span><br><span class="line"><span class="keyword">int</span> num=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;pnum&amp;&amp;prime[i]&lt;=sqrt;i++)&#123;</span><br><span class="line">  <span class="keyword">if</span>(n%prime[i]==<span class="number">0</span>)&#123;</span><br><span class="line">    fac[num].x=prime[i];</span><br><span class="line">    fac[num].cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(n%prime[i]==<span class="number">0</span>)&#123;</span><br><span class="line">      n/=prime[i];</span><br><span class="line">      fac[num].cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    num++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(n==<span class="number">1</span>)<span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(n!=<span class="number">1</span>)&#123;</span><br><span class="line">  fac[num].x=n;</span><br><span class="line">  fac[num++].cnt=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="大数">大数</h2><p>讨论极大数的运算（超出int和long的范围）</p><h2 id="存储">存储</h2><p>用一个结构体存储，包含存储数值的数组以及长度</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bign</span>&#123;</span></span><br><span class="line">  <span class="keyword">int</span> d[<span class="number">1000</span>];</span><br><span class="line">  <span class="keyword">int</span> len;</span><br><span class="line">  <span class="built_in">bign</span>()&#123;</span><br><span class="line">    <span class="built_in">memset</span>(d,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(d));<span class="comment">//把数组归0</span></span><br><span class="line">    len=<span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;；</span><br></pre></td></tr></table></figure><p>读取时先用字符串的形式读入，再把字符串转化为bign结构体</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">bign <span class="title">change</span><span class="params">(<span class="keyword">char</span> str[])</span></span>&#123;</span><br><span class="line">  bign a;</span><br><span class="line">  a.len=<span class="built_in">strlen</span>(str);</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.len;i++)&#123;</span><br><span class="line">    a.d[i]=str[a.len-i<span class="number">-1</span>]-<span class="string">&#x27;0&#x27;</span>;<span class="comment">//逆着赋值</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比较大小也很简单，先比len，若len相就从最高位依次比较</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(bign a,bign b)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(a.len&gt;b.len) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(a.len&lt;b.len) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=a.len<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">      <span class="keyword">if</span>(a.d[i]&gt;b.d[i])&#123;<span class="keyword">return</span> <span class="number">1</span>;&#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span>(a.d[i]&lt;b.d[i])&#123;<span class="keyword">return</span> <span class="number">-1</span>;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="运算">运算</h3><h4 id="加法-2">加法</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">bign <span class="title">add</span><span class="params">(bign a,bign b)</span></span>&#123;</span><br><span class="line">  bign c;</span><br><span class="line">  <span class="keyword">int</span> carry=<span class="number">0</span>;<span class="comment">//进位</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.len||i&lt;b.len;i++)&#123;</span><br><span class="line">    <span class="keyword">int</span> temp=a.d[i]+b.d[i]+carry;</span><br><span class="line">    c.d[c.len++]=temp%<span class="number">10</span>;</span><br><span class="line">    carry=temp/<span class="number">10</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(carry!=<span class="number">0</span>)&#123;</span><br><span class="line">    c.d[c.len++]=carry;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="减法">减法</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">bign <span class="title">sub</span><span class="params">(bign a,bign b)</span></span>&#123;</span><br><span class="line">  bign c;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.len||i&lt;b.len;i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.d[i]&lt;b.d[i])&#123;</span><br><span class="line">      a.d[i+<span class="number">1</span>]--;</span><br><span class="line">      a.d[i]+=<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    c.d[c.len++]=a.d[i]-b.d[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span>(c.len<span class="number">-1</span>&gt;=<span class="number">1</span>&amp;&amp;c.d[c.len<span class="number">-1</span>]==<span class="number">0</span>)&#123;</span><br><span class="line">    c.len--;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="乘法（与低精度）">乘法（与低精度）</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">bign <span class="title">multi</span><span class="params">(bign a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">  bign c;</span><br><span class="line">  <span class="keyword">int</span> carry=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.len;i++)&#123;</span><br><span class="line">    <span class="keyword">int</span> temp=a.d[i]*b+carry;</span><br><span class="line">    c.d[c.len++]=temp%<span class="number">10</span>;</span><br><span class="line">    carry=temp/<span class="number">10</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span>(carry!=<span class="number">0</span>)&#123;<span class="comment">//注意乘法的进位可能不止一位</span></span><br><span class="line">    c.d[c.len++]=carry%<span class="number">10</span>;</span><br><span class="line">    carry/=<span class="number">10</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="除法（与低精度）">除法（与低精度）</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">bign <span class="title">divide</span><span class="params">(bign a,<span class="keyword">int</span> b,<span class="keyword">int</span>&amp; r)</span></span>&#123;<span class="comment">//r为余数</span></span><br><span class="line">  bign c;</span><br><span class="line">  c.len=a.len;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=a.len<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">    r=r*<span class="number">10</span>+a.d[i];</span><br><span class="line">    <span class="keyword">if</span>(r&lt;b) c.d[i]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">      c.d[i]=r/b;</span><br><span class="line">      r=r%b;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span>(c.len<span class="number">-1</span>&gt;=<span class="number">1</span>&amp;&amp;c.d[c.len<span class="number">-1</span>]==<span class="number">0</span>)&#123;<span class="comment">//除去商前面多于的0</span></span><br><span class="line">    c.len--;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="扩展欧几里得算法">扩展欧几里得算法</h2><h3 id="ax-by-gcd-a-b"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi>x</mi><mo>+</mo><mi>b</mi><mi>y</mi><mo>=</mo><mi>g</mi><mi>c</mi><mi>d</mi><mo stretchy="false">(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">ax+by=gcd(a,b)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">a</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">b</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">c</span><span class="mord mathnormal">d</span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">b</span><span class="mclose">)</span></span></span></span></h3><p>首先易得必有x=1,y=0这组解，以此为递归边界不断计算<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi><mi>c</mi><mi>d</mi><mo stretchy="false">(</mo><mi>b</mi><mo separator="true">,</mo><mi>a</mi><mi mathvariant="normal">%</mi><mi>b</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">gcd(b,a\%b)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">c</span><span class="mord mathnormal">d</span><span class="mopen">(</span><span class="mord mathnormal">b</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">a</span><span class="mord">%</span><span class="mord mathnormal">b</span><span class="mclose">)</span></span></span></span>，得到递推公式为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mn>1</mn><mo>=</mo><mi>y</mi><mn>2</mn><mo separator="true">,</mo><mi>y</mi><mn>1</mn><mo>=</mo><mi>x</mi><mn>2</mn><mo>−</mo><mo stretchy="false">(</mo><mi>a</mi><mi mathvariant="normal">/</mi><mi>b</mi><mo stretchy="false">)</mo><mi>y</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">x1=y2,y1=x2-(a/b)y2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord mathnormal">x</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">x</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mord">/</span><span class="mord mathnormal">b</span><span class="mclose">)</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mord">2</span></span></span></span></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">exGcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> &amp;x,<span class="keyword">int</span> &amp;y)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(b==<span class="number">0</span>)&#123;</span><br><span class="line">    x=<span class="number">1</span>;</span><br><span class="line">    y=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span> g=<span class="built_in">exGcd</span>(b,a%b,x,y);</span><br><span class="line">  <span class="keyword">int</span> temp=x;</span><br><span class="line">  x=y;</span><br><span class="line">  y=temp-a/b*y;</span><br><span class="line">  <span class="keyword">return</span> g;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ax-by-c"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi>x</mi><mo>+</mo><mi>b</mi><mi>y</mi><mo>=</mo><mi>c</mi></mrow><annotation encoding="application/x-tex">ax+by=c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">a</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">b</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">c</span></span></span></span></h3><p>根据上述结论，该方程存在解的充要条件是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mi mathvariant="normal">%</mi><mi>g</mi><mi>c</mi><mi>d</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">c\%gcd=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.94444em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">c</span><span class="mord">%</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">c</span><span class="mord mathnormal">d</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>，且一组解为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>c</mi><mi>x</mi><mn>0</mn><mi mathvariant="normal">/</mi><mi>g</mi><mi>c</mi><mi>d</mi><mo separator="true">,</mo><mi>c</mi><mi>y</mi><mn>0</mn><mi mathvariant="normal">/</mi><mi>g</mi><mi>c</mi><mi>d</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(cx0/gcd,cy0/gcd)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">c</span><span class="mord mathnormal">x</span><span class="mord">0/</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">c</span><span class="mord mathnormal">d</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">cy</span><span class="mord">0/</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">c</span><span class="mord mathnormal">d</span><span class="mclose">)</span></span></span></span></p><p>全部解的公式为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mtext>’</mtext><mo>=</mo><mi>c</mi><mi>x</mi><mn>0</mn><mi mathvariant="normal">/</mi><mi>g</mi><mi>c</mi><mi>d</mi><mo>+</mo><mi>b</mi><mi mathvariant="normal">/</mi><mi>g</mi><mi>c</mi><mi>d</mi><mo>∗</mo><mi>K</mi><mo separator="true">,</mo><mi>y</mi><mtext>’</mtext><mo>=</mo><mi>c</mi><mi>y</mi><mn>0</mn><mi mathvariant="normal">/</mi><mi>g</mi><mi>c</mi><mi>d</mi><mo>−</mo><mi>a</mi><mi mathvariant="normal">/</mi><mi>g</mi><mi>c</mi><mi>d</mi><mo>∗</mo><mi>K</mi></mrow><annotation encoding="application/x-tex">x’=cx0/gcd+b/gcd*K,y’=cy0/gcd-a/gcd*K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">x</span><span class="mord">’</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">c</span><span class="mord mathnormal">x</span><span class="mord">0/</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">c</span><span class="mord mathnormal">d</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">b</span><span class="mord">/</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">c</span><span class="mord mathnormal">d</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mord">’</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">cy</span><span class="mord">0/</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">c</span><span class="mord mathnormal">d</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">a</span><span class="mord">/</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">c</span><span class="mord mathnormal">d</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span></span></span></span>（K为任意整数）</p><h3 id="ax-c-m-0"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>a</mi><mi>x</mi><mo>−</mo><mi>c</mi><mo stretchy="false">)</mo><mi mathvariant="normal">%</mi><mi>m</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">(ax-c)\%m=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">c</span><span class="mclose">)</span><span class="mord">%</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span></h3><p>先求解<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi>x</mi><mo>+</mo><mi>m</mi><mi>y</mi><mo>=</mo><mi>g</mi><mi>c</mi><mi>d</mi><mo stretchy="false">(</mo><mi>a</mi><mo separator="true">,</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">ax+my=gcd(a,m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">a</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">m</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">c</span><span class="mord mathnormal">d</span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">m</span><span class="mclose">)</span></span></span></span>，然后代入<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>=</mo><mi>c</mi><mi>x</mi><mn>0</mn><mi mathvariant="normal">/</mi><mi>g</mi><mi>c</mi><mi>d</mi><mo stretchy="false">(</mo><mi>a</mi><mo separator="true">,</mo><mi>m</mi><mo stretchy="false">)</mo><mo separator="true">,</mo><mi>y</mi><mo>=</mo><mi>c</mi><mi>y</mi><mn>0</mn><mi mathvariant="normal">/</mi><mi>g</mi><mi>c</mi><mi>d</mi><mo stretchy="false">(</mo><mi>a</mi><mo separator="true">,</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">x=cx0/gcd(a,m),y=cy0/gcd(a,m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">c</span><span class="mord mathnormal">x</span><span class="mord">0/</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">c</span><span class="mord mathnormal">d</span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">m</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">cy</span><span class="mord">0/</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">c</span><span class="mord mathnormal">d</span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">m</span><span class="mclose">)</span></span></span></span></p><p>得到<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mtext>’</mtext><mo>=</mo><mi>x</mi><mo>+</mo><mi>m</mi><mi mathvariant="normal">/</mi><mi>g</mi><mi>c</mi><mi>d</mi><mo stretchy="false">(</mo><mi>a</mi><mo separator="true">,</mo><mi>m</mi><mo stretchy="false">)</mo><mo>∗</mo><mi>K</mi><mo separator="true">,</mo><mi>y</mi><mtext>’</mtext><mo>=</mo><mi>y</mi><mo>−</mo><mi>a</mi><mi mathvariant="normal">/</mi><mi>g</mi><mi>c</mi><mi>d</mi><mo stretchy="false">(</mo><mi>a</mi><mo separator="true">,</mo><mi>m</mi><mo stretchy="false">)</mo><mo>∗</mo><mi>K</mi></mrow><annotation encoding="application/x-tex">x’=x+m/gcd(a,m)*K,y’=y-a/gcd(a,m)*K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">x</span><span class="mord">’</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">m</span><span class="mord">/</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">c</span><span class="mord mathnormal">d</span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">m</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mord">’</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7777700000000001em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">a</span><span class="mord">/</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">c</span><span class="mord mathnormal">d</span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">m</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span></span></span></span>（K为任意整数）</p><h2 id="组合数">组合数</h2><h3 id="n-的质因子">n!的质因子</h3><p>n!有（n/p+n/p^2^+n/p^3^+……）个质因子p</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cal</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(n)&#123;</span><br><span class="line">    ans+=n/p;</span><br><span class="line">    n/=p;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="组合数计算">组合数计算</h3><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>C</mi><mi>n</mi><mi>m</mi></msubsup><mo>=</mo><mfrac><mrow><mi>n</mi><mo stretchy="false">!</mo></mrow><mrow><mi>m</mi><mo stretchy="false">!</mo><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mi>m</mi><mo stretchy="false">)</mo><mo stretchy="false">!</mo></mrow></mfrac></mrow><annotation encoding="application/x-tex">C_{n}^{m}=\frac{n!}{m!(n-m)!}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.93033em;vertical-align:-0.247em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-2.4530000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.400108em;vertical-align:-0.52em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8801079999999999em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span><span class="mclose mtight">!</span><span class="mopen mtight">(</span><span class="mord mathnormal mtight">n</span><span class="mbin mtight">−</span><span class="mord mathnormal mtight">m</span><span class="mclose mtight">)!</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mclose mtight">!</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.52em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">C</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> n,<span class="keyword">long</span> <span class="keyword">long</span> m)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(m==<span class="number">0</span>||n==n)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">C</span>(n<span class="number">-1</span>,m)+<span class="built_in">C</span>(n<span class="number">-1</span>,m<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="C-n-m-p"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>C</mi><mi>n</mi><mi>m</mi></msubsup><mi mathvariant="normal">%</mi><mi>p</mi></mrow><annotation encoding="application/x-tex">C_{n}^{m}\%p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.997em;vertical-align:-0.247em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-2.4530000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span><span class="mord">%</span><span class="mord mathnormal">p</span></span></span></span></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> res[<span class="number">1010</span>][<span class="number">1010</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">C</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m, <span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(m==<span class="number">0</span>||m==n) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span>(res[n][m]!=<span class="number">0</span>) <span class="keyword">return</span> res[n][m];</span><br><span class="line">  <span class="keyword">return</span> res[n][m]=(<span class="built_in">C</span>(n<span class="number">-1</span>,m)+<span class="built_in">C</span>(n<span class="number">-1</span>,m<span class="number">-1</span>))%p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>排序与二分</title>
      <link href="2021/02/19/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
      <url>2021/02/19/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="快速排序">快速排序</h2><p>选定一个数，然后把所有大于（小于）这个数的放到一边，再用递归分别对左右两边不停进行一样的操作即可。</p><p>用two pionts思想，指针从两端往中间走，遇到大于（小于）（不符合条件）的停下，然后交换两个指针对应的值继续走，代码模板如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quick_sort</span><span class="params">(<span class="keyword">int</span> q[], <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i = l - <span class="number">1</span>, j = r + <span class="number">1</span>, x = q[l + r &gt;&gt; <span class="number">1</span>];<span class="comment">//x可以取任意一个值，但后面会有所区别</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">do</span> i ++ ; <span class="keyword">while</span> (q[i] &lt; x);</span><br><span class="line">        <span class="keyword">do</span> j -- ; <span class="keyword">while</span> (q[j] &gt; x);</span><br><span class="line">        <span class="keyword">if</span> (i &lt; j) <span class="built_in">swap</span>(q[i], q[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">quick_sort</span>(q, l, j), <span class="built_in">quick_sort</span>(q, j + <span class="number">1</span>, r);<span class="comment">//x能取到q[l]就用j表示，取不到就把j用i-1代替</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="归并排序">归并排序</h2><p>用二分法将数组二分至最小（1个或者两个），然后对每个数组进行排序，再不停合并数组（在合并过程中有序排列）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge_sort</span><span class="params">(<span class="keyword">int</span> q[], <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">merge_sort</span>(q, l, mid);</span><br><span class="line">    <span class="built_in">merge_sort</span>(q, mid + <span class="number">1</span>, r);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>, i = l, j = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= r)</span><br><span class="line">        <span class="keyword">if</span> (q[i] &lt;= q[j]) tmp[k ++ ] = q[i ++ ];</span><br><span class="line">        <span class="keyword">else</span> tmp[k ++ ] = q[j ++ ];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid) tmp[k ++ ] = q[i ++ ];</span><br><span class="line">    <span class="keyword">while</span> (j &lt;= r) tmp[k ++ ] = q[j ++ ];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = l, j = <span class="number">0</span>; i &lt;= r; i ++, j ++ ) q[i] = tmp[j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二分">二分</h2><p>二分的核心思想是寻找序列中的一个值使得这个值左边或者右边满足某个性质</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;<span class="comment">/* ... */</span>&#125; <span class="comment">// 检查x是否满足某种性质</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bsearch_1</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(mid)) r = mid;    <span class="comment">// check()判断mid是否满足性质</span></span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 区间[l, r]被划分成[l, mid - 1]和[mid, r]时使用：</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bsearch_2</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = l + r + <span class="number">1</span> &gt;&gt; <span class="number">1</span>;<span class="comment">//注意这里有个+1</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(mid)) l = mid;</span><br><span class="line">        <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《算法笔记》第四章</title>
      <link href="2021/02/02/%E3%80%8A%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0%E3%80%8B%E7%AC%AC%E5%9B%9B%E7%AB%A0/"/>
      <url>2021/02/02/%E3%80%8A%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0%E3%80%8B%E7%AC%AC%E5%9B%9B%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<h1>《算法笔记》第四章</h1><h2 id="排序">排序</h2><p>排序算法的思想都比较简单，而且c++可以直接用sort函数进行排序，一般不会直接写排序代码</p><p>归根到底就是每轮处理一个数据，n个数据只需处理n-1次即可变得有序</p><h3 id="选择排序">选择排序</h3><p>最简单的排序，每轮找出一个最值移到相应位置即可，代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">selectsort</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n<span class="number">-1</span>;i++)&#123;</span><br><span class="line">    <span class="keyword">int</span> k=i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j=k;j&lt;=n;j++)&#123;</span><br><span class="line">      <span class="keyword">if</span>(a[j]&gt;a[k])&#123;</span><br><span class="line">        k=j;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="keyword">if</span>(i!=k)&#123;</span><br><span class="line">      <span class="keyword">int</span> temp=a[i];</span><br><span class="line">      a[i]=a[k];</span><br><span class="line">      a[k]=temp;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="插入排序">插入排序</h3><p>每轮将一个数据插入已排好的数据中，代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertsort</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">    <span class="keyword">int</span> temp=a[i],j=i;</span><br><span class="line">    <span class="keyword">while</span>(j&gt;<span class="number">1</span>&amp;&amp;temp&lt;a[j<span class="number">-1</span>])&#123;</span><br><span class="line">      a[j]=a[j<span class="number">-1</span>];</span><br><span class="line">      j--;</span><br><span class="line">    &#125;</span><br><span class="line">    a[j]=temp;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="sort函数">sort函数</h3><p>使用前需加上头文件</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="built_in">sort</span>(首元素地址,尾元素地址的下一个地址,比较函数(非必填));</span><br></pre></td></tr></table></figure><p>如不写比较函数，则默认升序</p><h4 id="比较函数">比较函数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a&gt;b;<span class="comment">//可以理解为当a&gt;b时把a放在b前面，这样就实现了降序</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="对结构体排序">对结构体排序</h3><p>定义如下结构体</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">  <span class="keyword">int</span> x,y;</span><br><span class="line">&#125;ssd[<span class="number">10</span>];</span><br></pre></td></tr></table></figure><p>则比较函数为</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(node a,node b)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a.x&gt;b.x;<span class="comment">//按x值降序</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如需二级排序，也可以</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(node a, node b)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(a.x != b.x)&#123;<span class="keyword">return</span> a.x&gt;b.x;&#125;</span><br><span class="line">  <span class="keyword">else</span>&#123;<span class="keyword">return</span> a.y&gt;b.y;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="散列">散列</h2><p>散列对于我来说是一个之前从来没有接触过的全新的算法思想</p><p>其核心思想是用空间换时间，用数组的下标来表示数据，代码如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> hashtable[maxn]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n,m,x;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,n,m);</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">    hashtable[x]++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>,i&lt;m,i++)&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,hashtable[x]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码能输出m个数据分别在n个数据中出现的次数</p><p>由此，只要将数据的值转换为数组的下标，即可省去将数组遍历一遍的繁琐</p><p>除了正常的十进制整数之外，字符也可以通过一定的转化方式转化为哈希数组的下标，这里的思路是，将字符转化为一个整数使得这个整数能唯一地表示这个字符，这里可以根据字符的种类数n定义一个n进制的坐标，比如26个字母就可以将a转化为0，z转化为25，用26进制表示一个字符串。输入时将这个字符串转化为26进制等价的十进制数，这个十进制数就是该字符串的下标，可见这个下标对于特定的字符串是独一无二的。代码如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hashfunc</span><span class="params">(<span class="keyword">char</span> s[],<span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> id=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">    id=id*<span class="number">26</span>+(s[i]-<span class="string">&#x27;a&#x27;</span>)<span class="comment">//此处注意a必须是单引号，因为单引号才代表字符，双引号代表的是字符串数组</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实不难发现，这个转化的函数就是把s[i]-'a’转化为26进制。</p><p>上面仅考虑了小写字母，如果是一段正常的字符串，那么还有大写字母和数字，只需如法炮制，增大进制数为62即可。</p><h2 id="递归">递归</h2><p>递归的核心思想就是反复调用自身。</p><p>递归的一个重要作用是分治，也就是把一个问题划分为若干个小问题，分别解决这些小问题然后合并解就是原问题的解。</p><p>最经典的递归函数就是求斐波那契数列了，代码如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">F</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(n==<span class="number">1</span>||n==<span class="number">2</span>)&#123;<span class="keyword">return</span> <span class="number">1</span>;&#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">F</span>(n<span class="number">-1</span>)+<span class="built_in">F</span>(n<span class="number">-2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>递归函数最重要的两件东西：递归边界和递归式。</p><p>递归边界就是最简单问题的解，递归式就是把问题分解为简单问题的方式。</p><p>在求斐波那契数列中，F(1)=F(2)=1就是递归边界，F(n)=F(n-1)+F(n-2)就是递归式</p><p>运用递归和哈希的思想，还能实现一些其他算法，比如输出n个数的全排列，代码如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">generateP</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(index == n+<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,P[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> x=<span class="number">1</span>;x&lt;=n;x++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(hashtable[x]==<span class="literal">false</span>)&#123;</span><br><span class="line">      P[index]=x;</span><br><span class="line">      hashtable[x]=<span class="literal">true</span>;</span><br><span class="line">      <span class="built_in">generateP</span>(index+<span class="number">1</span>);</span><br><span class="line">      hashtable[x]=<span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运用这个全排列思想，还可以优化解决n皇后问题（即把n个皇后放在n*n棋盘上，要求不同行列和对角线），代码如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">generateP</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(index==n+<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="keyword">bool</span> flag=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">abs</span>(i-j)==<span class="built_in">abs</span>(P[i]-P[j]))&#123;</span><br><span class="line">          flag=<span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(flag)&#123;count++;&#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> x=<span class="number">1</span>;x&lt;=n;x++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(hashtable[x]==<span class="literal">false</span>)&#123;</span><br><span class="line">      P[index]=x;</span><br><span class="line">      hashtable[x]=<span class="literal">true</span>;</span><br><span class="line">      <span class="built_in">generateP</span>(index+<span class="number">1</span>);</span><br><span class="line">      hashtable[x]=<span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以发现，这段代码其实和之前求全排列代码就是上半部分有改变，上半部分其实就是递归边界，全排列的边界是index=n+1就输出，而n皇后其实就是在index=n+1的基础上多判断了一步对角线是否相等。</p><p>这个算法还可以进行一点优化，不用把全排列都列出来再判断，可以回溯之前已经摆下的棋子判断是否冲突（即是否在同一条对角线），如果冲突那就下一个，这样可以省去一些无用的计算，代码如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">generateP</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(index==n+<span class="number">1</span>)&#123;</span><br><span class="line">    count++;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> x=<span class="number">1</span>;x&lt;=n;x++)&#123;</span><br><span class="line">    <span class="keyword">if</span> (hashtable[x]==<span class="literal">false</span>)&#123;</span><br><span class="line">      <span class="keyword">bool</span> flag=<span class="literal">true</span>;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> pre=<span class="number">1</span>;pre&lt;index;pre++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">abs</span>(index-pre)==<span class="built_in">abs</span>(x-P[pre]))&#123;</span><br><span class="line">          flag=<span class="literal">false</span>;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">        P[index]=x;</span><br><span class="line">        hashtable[x]=<span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">generateP</span>(index+<span class="number">1</span>);</span><br><span class="line">        hashtable[x]=<span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>递归算是我学习以来比较难理解的一块内容了，代码虽然勉强能看懂，其实中间有很多细节是要靠自己细细体会的，慢慢来吧。</p><h2 id="贪心算法">贪心算法</h2><p>贪心算法主要用来解决求最优的问题，而很多情况下我们无法一下子实现全局最优，于是就可以考虑在当前状态下实现局部最优，然后达到全局最优。</p><p>简单的贪心算法比如给一串数字输出最大（小）数等等，这些难度都不大。</p><p>还有一类区间不相交的问题，即从一堆给定区间中找出尽可能多的不相交区间。</p><p>解决这个问题的思路是首先考虑有无区间包含，若有区间包含了另一个区间则将其舍去，因为小区间可以腾出更多的空间。其次只需按照左端点从大到小依次选下去即可（按右端点从小到大也行），核心代码如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Inteval</span>&#123;</span></span><br><span class="line">  <span class="keyword">int</span> x,y;</span><br><span class="line">&#125;I[maxn];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bmp</span><span class="params">(Inteval a,Inteval b)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(a.x!=b.x)&#123;</span><br><span class="line">    <span class="keyword">return</span> a.x&gt;b.x;</span><br><span class="line">  &#125;<span class="keyword">else</span> <span class="keyword">return</span> a.y&lt;b.y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n;</span><br><span class="line">  <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n),n!=<span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;I[i].x,&amp;I[i].y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(I,I+n,cmp);</span><br><span class="line">    <span class="keyword">int</span> count=<span class="number">1</span>,last=I[<span class="number">0</span>].x;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">      <span class="keyword">if</span>(I[i].y&lt;=last)&#123;</span><br><span class="line">        last=I[i].x;</span><br><span class="line">        count++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,count);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二分">二分</h2><p>二分的算法其实不仅仅是用在计算机上，平时生活中也经常用到二分的思想。</p><p>在面对未知的情况时，折中似乎是一种最有效的方法。不停地折中，逼近正确答案的概率也就越大。尤其是在面对有序数列时，二分就能知道答案存在的大致区间然后缩小这个区间，不用一个个寻找。</p><p>代码如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(left&lt;=right)&#123;</span><br><span class="line">  mid=(left+right)/<span class="number">2</span>;</span><br><span class="line">  <span class="keyword">if</span>(a[mid]==x)&#123;</span><br><span class="line">    <span class="keyword">return</span> mid;</span><br><span class="line">  &#125;<span class="keyword">else</span> <span class="keyword">if</span>(a[mid]&gt;x)&#123;</span><br><span class="line">    right=mid<span class="number">-1</span>;</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    left=mid+<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;<span class="comment">//查找失败</span></span><br></pre></td></tr></table></figure><p>这是最简单的二分查找，在实际的二分查找中经常会遇到输出第一个满足某条件的位置，通用代码如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(left&lt;right)&#123;<span class="comment">//如果left和right相等，意味着找到唯一位置</span></span><br><span class="line">  mid=(left+right)/<span class="number">2</span>;</span><br><span class="line">   <span class="keyword">if</span>(条件)&#123;</span><br><span class="line">    right=mid;</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    left=mid+<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> left;</span><br></pre></td></tr></table></figure><p>这段代码能输出第一个满足该条件的位置，并且<strong>该条件必须在序列中从左到右先不满足后满足</strong>如果不是的话取反即可。</p><p>除了查找之外，二分法还有其他的作用，比如估计无理数的近似值</p><p>以<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msqrt><mn>2</mn></msqrt></mrow><annotation encoding="application/x-tex">\sqrt{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.04em;vertical-align:-0.13278em;"></span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.90722em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord" style="padding-left:0.833em;"><span class="mord">2</span></span></span><span style="top:-2.86722em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em;"><svg width='400em' height='1.08em' viewBox='0 0 400000 1080' preserveAspectRatio='xMinYMin slice'><path d='M95,702c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,-221l0 -0c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47zM834 80h400000v40h-400000z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.13278em;"><span></span></span></span></span></span></span></span></span>为例，定义一个函数<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><msup><mi>x</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">f(x)=x^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span>，而<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msqrt><mn>2</mn></msqrt></mrow><annotation encoding="application/x-tex">\sqrt{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.04em;vertical-align:-0.13278em;"></span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.90722em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord" style="padding-left:0.833em;"><span class="mord">2</span></span></span><span style="top:-2.86722em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em;"><svg width='400em' height='1.08em' viewBox='0 0 400000 1080' preserveAspectRatio='xMinYMin slice'><path d='M95,702c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,-221l0 -0c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47zM834 80h400000v40h-400000z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.13278em;"><span></span></span></span></span></span></span></span></span>的值又必定在1和2之间，所以只需找出一个逼近<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msqrt><mn>2</mn></msqrt></mrow><annotation encoding="application/x-tex">\sqrt{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.04em;vertical-align:-0.13278em;"></span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.90722em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord" style="padding-left:0.833em;"><span class="mord">2</span></span></span><span style="top:-2.86722em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em;"><svg width='400em' height='1.08em' viewBox='0 0 400000 1080' preserveAspectRatio='xMinYMin slice'><path d='M95,702c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,-221l0 -0c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47zM834 80h400000v40h-400000z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.13278em;"><span></span></span></span></span></span></span></span></span>的值(这里设精度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><msup><mn>0</mn><mrow><mo>−</mo><mn>5</mn></mrow></msup></mrow><annotation encoding="application/x-tex">10^{-5}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span></span>)，初始的二分区间为[1,2]，只要将区间缩小到<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><msup><mn>0</mn><mrow><mo>−</mo><mn>5</mn></mrow></msup></mrow><annotation encoding="application/x-tex">10^{-5}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span></span>即可，代码如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">f</span><span class="params">(<span class="keyword">double</span> x)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x*x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">calSqrt</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">double</span> left=<span class="number">1</span>,right=<span class="number">2</span>,mid;</span><br><span class="line">  <span class="keyword">while</span>(right-left&gt;<span class="number">1e-5</span>)&#123;</span><br><span class="line">    mid=(right+left)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">f</span>(mid)&gt;<span class="number">2</span>)&#123;</span><br><span class="line">      right=mid;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      left=mid;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> mid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再推广一下，可以用该方法解决任何求f(x)=0方程解的代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">f</span><span class="params">(<span class="keyword">double</span> x)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> 函数;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">calSqrt</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">double</span> left=<span class="number">1</span>,right=<span class="number">2</span>,mid;</span><br><span class="line">  <span class="keyword">while</span>(right-left&gt;精度)&#123;</span><br><span class="line">    mid=(right+left)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">f</span>(mid)&gt;<span class="number">0</span>)&#123;<span class="comment">//若f(x)递减，则改为&lt;0</span></span><br><span class="line">      right=mid;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      left=mid;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> mid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以得出二分可以用来解决一类答案在一个单调区间内的问题，设置好精度和关系，不停地二分尝试即可。</p><h3 id="快速幂">快速幂</h3><p>求高次幂经常会溢出而且要进行多步循环，所以可以用二分的思想把幂运算拆分，即<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>a</mi><mrow><mn>2</mn><mi>n</mi></mrow></msup><mo>=</mo><msup><mi>a</mi><mi>n</mi></msup><mo>∗</mo><msup><mi>a</mi><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">a^{2n}=a^n*a^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.664392em;vertical-align:0em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.664392em;vertical-align:0em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>a</mi><mrow><mn>2</mn><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msup><mo>=</mo><msup><mi>a</mi><mrow><mn>2</mn><mi>n</mi></mrow></msup><mo>∗</mo><mi>a</mi></mrow><annotation encoding="application/x-tex">a^{2n+1}=a^{2n}*a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mathnormal mtight">n</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">a</span></span></span></span>，运用这个思路就可以用递归的思想求高次幂，代码如下(计算<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>a</mi><mi>b</mi></msup></mrow><annotation encoding="application/x-tex">a^b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.849108em;vertical-align:0em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">b</span></span></span></span></span></span></span></span></span></span></span>%m)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">binarypow</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> a,<span class="keyword">long</span> <span class="keyword">long</span> b,<span class="keyword">long</span> <span class="keyword">long</span> m)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(b==<span class="number">0</span>)<span class="keyword">return</span><span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">if</span>(b%<span class="number">2</span>==<span class="number">1</span>)<span class="keyword">return</span> a*<span class="built_in">binarypow</span>(a,b<span class="number">-1</span>,m)%m;</span><br><span class="line">  <span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> mul=<span class="built_in">binarypow</span>(a,b/<span class="number">2</span>,m);</span><br><span class="line">    <span class="keyword">return</span> mul*mul%m;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了递归的思路之外，还可以用迭代的思想计算。</p><p>具体思路是把b看成二进制数，然后就可以把<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>a</mi><mi>b</mi></msup></mrow><annotation encoding="application/x-tex">a^b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.849108em;vertical-align:0em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">b</span></span></span></span></span></span></span></span></span></span></span>拆分成若干<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>a</mi><mrow><mn>2</mn><mi>k</mi></mrow></msup></mrow><annotation encoding="application/x-tex">a^{2k}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.849108em;vertical-align:0em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span></span></span></span></span>的乘积，具体代码如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">binarypow</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> a,<span class="keyword">long</span> <span class="keyword">long</span> b,<span class="keyword">long</span> <span class="keyword">long</span> m)</span></span>&#123;</span><br><span class="line">  <span class="keyword">long</span> <span class="keyword">long</span> ans=<span class="number">1</span>;</span><br><span class="line">  <span class="built_in">whlie</span>(b&gt;<span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(b&amp;<span class="number">1</span>)&#123;<span class="comment">//b的末尾是否为1，即b%2=1</span></span><br><span class="line">      ans=ans*a%m;</span><br><span class="line">    &#125;</span><br><span class="line">    a=a*a%m;</span><br><span class="line">    b&gt;&gt;=<span class="number">1</span>;<span class="comment">//将b右移一位，即b=b/2</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="two-pointers">two pointers</h2><p>这个不是具体的算法，可以说是一种算法思想吧，当用一个循环变量枚举比较复杂时，改用两个循环变量，可以大大降低算法复杂度</p><p>具体的例子就是，从有序数列中找出两个数使其和为M，常规的逻辑当然是双层循环一个个试，但这样当数列很大时O(n^2^)的复杂度就不太方便，而运用two pointers的思想则能大大优化，代码如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(i&lt;j)&#123;</span><br><span class="line">  <span class="keyword">if</span>(a[i]+a[j]==M)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d%d&quot;</span>,i,j);</span><br><span class="line">    i++;</span><br><span class="line">    j--;</span><br><span class="line">  &#125;<span class="keyword">else</span> <span class="keyword">if</span>(a[i]+a[j]&gt;M)&#123;</span><br><span class="line">    j--;</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    i++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="归并排序">归并排序</h3><p>归并排序的思想是先把无序序列拆成若干个2个数的小序列，然后在小序列里面各自排序，排好后两两合并小序列继续排序，直到合并成一个序列。</p><h3 id="快速排序">快速排序</h3><p>运用two pointers方法，从序列的两头将大于某个值的数放到一边，小于的放到另一边，遍历整个序列即可，代码如下。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> temp=a[left];</span><br><span class="line">  <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">    <span class="keyword">while</span>(left&lt;right &amp;&amp; a[right]&gt;temp)&#123;right--;&#125;</span><br><span class="line">    a[left]=a[right];</span><br><span class="line">    <span class="keyword">while</span>(left&lt;right &amp;&amp; a[left]&lt;=temp)&#123;left++;&#125;</span><br><span class="line">    a[right]=a[left];</span><br><span class="line">  &#125;</span><br><span class="line">  a[left]=temp;</span><br><span class="line">  <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quicksort</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(left&lt;right)&#123;</span><br><span class="line">    <span class="keyword">int</span> pos=<span class="built_in">partition</span>(a,left,right);</span><br><span class="line">    <span class="built_in">quicksort</span>(a,left,pos<span class="number">-1</span>);<span class="comment">//对左边区间排序</span></span><br><span class="line">    <span class="built_in">quicksort</span>(a,pos+<span class="number">1</span>,right);<span class="comment">//对右边区间排序</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个算法还可以用于判断a[left]是数组中第几大的数</p><h2 id="其他技巧">其他技巧</h2><ol><li>在一些算法中（尤其是一些递归算法中），前面计算的结果可能在后面也用的上，这时就可以先把这些数据输出或者存储起来，等到后面再需要用到的时候就不用重新计算了，以递归法求斐波那契数列为例，越到后面计算量会变得很大，这时候来一个数组存储之前的数就能大大降低计算量</li><li>如果算法比较复杂容易超时，可以在本地运行出结果然后直接在题目里面输出，也可以在本地先小规模地试一下找找规律。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《算法笔记》第三章</title>
      <link href="2020/12/19/%E3%80%8A%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0%E3%80%8B%E7%AC%AC%E4%B8%89%E7%AB%A0/"/>
      <url>2020/12/19/%E3%80%8A%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0%E3%80%8B%E7%AC%AC%E4%B8%89%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<h1>算法笔记《第三章》</h1><p>第三章没有啥具体的知识点，主要是讲一些简单的算法，顺便巩固一下之前学的语法。</p><p>以下我就罗列一下我学习过程中遇到的问题吧。</p><h2 id="一个是for语句中的循环变量问题">一个是for语句中的循环变量问题</h2><p>循环是各种算法里面经常接触到的语法，而循环的精髓就在于循环变量的操作，常见的for循环是这样的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种形式的循环会执行n次，而第x次循环中i的值为x-1，这种类型大多用于对数组的操作，因为第x个数组对应的坐标就是x-1</p><p>还有一种是这样的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种循环也会执行n次，区别是第x次循环中i的值就是x，这种类型适用于编号。</p><p>上述两类都是在循环内定义变量并赋初值的，也可以在循环外定义变量和赋值，这样这个变量经过循环后会发生相应改变，在某些算法里面也许会有用，不过我感觉如果真的需要这个数据可以重新再定义一个，把循环变量和其他变量区别开不容易搞混。</p><h2 id="数组的下标问题">数组的下标问题</h2><p>一个算法会给一个输入的上限，根据这个上限去选择合适的数组大小，一般都会比这个大一些，一个是因为末尾有空字符串，另一个我记得在数据结构与算法里面学到过对于目前的计算机来说空间是比较足够的，所以在取舍空间和时间时优先时间。</p><h2 id="字符数组的长度">字符数组的长度</h2><p>之前就记得末尾会有空字符串了，但忘了strlen函数是会自动忽略最后那个空字符串的</p><h2 id="长串数据输入">长串数据输入</h2><p>可以使用语句</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n)!=EOF)&#123;&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《算法笔记》第二章</title>
      <link href="2020/12/10/%E3%80%8A%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0%E3%80%8B%E7%AC%AC%E4%BA%8C%E7%AB%A0/"/>
      <url>2020/12/10/%E3%80%8A%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0%E3%80%8B%E7%AC%AC%E4%BA%8C%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<h1>《算法笔记》</h1><p>这本书是一个学长推荐我的，听说对零基础入门很友好，还有配套的刷题网站，这点很重要。<br>我一直认为，要学好一样东西，最快最直接的方式就是实践，如果只是看书，就会像我高中一样纸上谈兵，空会理论而不会实际的编程，况且多敲代码对于我记忆那些知识点也是很有帮助的。<br>C语言程序设计我之前是跟着我们学校翁恺老师的慕课学的，把基础的语法点刚看完，看到了指针那块，现在开始看《算法笔记》，就当把之前的知识点都复习一遍了。<br>而且这本书和传统的C语言学习不同，它介绍的是C和C++的语法，并且它介绍的语法是针对刷题的，并不是面面俱到，这对我这种刚入门的小白比较友好，学了就可以用。</p><h2 id="C语言基本知识点">C语言基本知识点</h2><p>刚入门C语言，见的第一段代码肯定是这样的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在C++里面第一句也可以写成</p><p><code>#include&lt;cstdio&gt;</code></p><h2 id="数据类型">数据类型</h2><h3 id="数据存储形式">数据存储形式</h3><p>计算机中，整除采用补码的方式存储，以1个字节（8bit）的char类型为例</p><p>为了让正数和负数能直接相加减，负数<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">−</span><span class="mord">1</span></span></span></span>的二进制为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">0-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>，表现为二进制就是(1)00000000-00000001=11111111，这样子<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>1</mn><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">-1+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">−</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>就能等于0了，这也解释了一个字节的char类型为什么数据范围是-128到127，表现为二进制就是10000000到01111111，</p><h3 id="变量类型">变量类型</h3><table><thead><tr><th>名称</th><th>说明</th></tr></thead><tbody><tr><td>int</td><td>最常用的整型 4字节 %d</td></tr><tr><td>long long</td><td>范围更大的整型 8字节</td></tr><tr><td>float</td><td>浮点型 但精度较小 %f</td></tr><tr><td>double</td><td>常用的浮点型 精度较高 %lf</td></tr><tr><td>char</td><td>字符型 %c，1字节</td></tr><tr><td>bool</td><td>布尔型(在C++里面才能直接用)</td></tr></tbody></table><p><strong>注：数据在计算机内存储均是二进制，只是输入输出时格式不同罢了</strong></p><h3 id="类型转换">类型转换</h3><p><code>(新类型名)变量名</code></p><h3 id="定义常量">定义常量</h3><p><code>const 数据类型 变量名 = 常量；</code></p><h3 id="数值运算符">数值运算符</h3><p>+，-，*这三个没什么可说的</p><p>/   这个是<strong>整除</strong></p><p>% 这个是<strong>取余</strong>，取余的结果正负只和被取余的正负有关</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">i++是先调用i后加</span><br><span class="line">++i是先加后调用i</span><br><span class="line">两者就差了个<span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="关系运算符">关系运算符</h3><table><thead><tr><th>运算符</th><th>含义</th></tr></thead><tbody><tr><td>&lt;</td><td>小于</td></tr><tr><td>&gt;</td><td>大于</td></tr><tr><td>&lt;=</td><td>小于等于</td></tr><tr><td>&gt;=</td><td>大于等于</td></tr><tr><td>==</td><td>等于（<strong>注意是两个等于！</strong>）</td></tr><tr><td>!=</td><td>不等于</td></tr></tbody></table><h3 id="逻辑运算符">逻辑运算符</h3><table><thead><tr><th>运算符</th><th>含义</th></tr></thead><tbody><tr><td>&amp;&amp;</td><td>与</td></tr><tr><td>||</td><td>或</td></tr><tr><td>!</td><td>非</td></tr></tbody></table><h3 id="条件运算符">条件运算符</h3><p><code>A?B:C;</code></p><p>这段代码的含义是如果A为真就返回B否则C</p><p>我觉得这个运算符很好用，相当于一个很简洁的判断语句</p><h3 id="位运算符">位运算符</h3><p>这个我以前从没有接触过，也不知道有什么用，就先记着吧</p><table><thead><tr><th>运算符</th><th>含义</th></tr></thead><tbody><tr><td>&lt;&lt;</td><td>左移</td></tr><tr><td>&gt;&gt;</td><td>右移</td></tr><tr><td>&amp;</td><td>位与</td></tr><tr><td>|</td><td>位或</td></tr><tr><td>^</td><td>位异或</td></tr><tr><td>`</td><td>位取反</td></tr></tbody></table><h2 id="顺序结构">顺序结构</h2><h3 id="赋值表达式">赋值表达式</h3><p><code>变量类型 变量名=初值;</code></p><h3 id="输入">输入</h3><p><code>scanf(&quot;格式&quot;,&amp;变量);</code></p><p>变量前面要记得加&amp;代表地址</p><table><thead><tr><th>数据类型</th><th>格式符</th></tr></thead><tbody><tr><td>int</td><td>%d</td></tr><tr><td>long long</td><td>%lld</td></tr><tr><td>float</td><td>%f</td></tr><tr><td>double</td><td>%lf</td></tr><tr><td>char</td><td>%c</td></tr><tr><td>字符串</td><td>%s，此处不用加&amp;</td></tr></tbody></table><h3 id="输出">输出</h3><p><code>printf(&quot;格式&quot;,变量);</code></p><table><thead><tr><th>数据类型</th><th>格式符</th></tr></thead><tbody><tr><td>int</td><td>%md（m表示不足m位的以m位右对齐），%0md（用0替换之前的空格）</td></tr><tr><td>long long</td><td>%lld</td></tr><tr><td>float</td><td>%f</td></tr><tr><td>double</td><td>%f，%.mf（m表示小数位数）</td></tr><tr><td>char</td><td>%c</td></tr><tr><td>字符串</td><td>%s</td></tr></tbody></table><p><strong>注意double的格式从%lf变成了%f，即输入lf，输出f</strong></p><p>也可以用getchar()读入<strong>单个</strong>字符</p><p>用putchar()输出<strong>单个</strong>字符</p><h3 id="注释">注释</h3><p><code>//注释</code></p><p>//后的话都不会被执行</p><h3 id="数学函数">数学函数</h3><p>需要在前面加上</p><p><code>include&lt;math.h&gt;</code></p><p>所有的对象都是double 类型</p><table><thead><tr><th>函数</th><th>用法</th></tr></thead><tbody><tr><td>fabs()</td><td>绝对值</td></tr><tr><td>floor()，ceil()</td><td>均用于double变量，floor向下取整。ceil向上取整</td></tr><tr><td>pow(r,p)</td><td>返回r^p^</td></tr><tr><td>sqrt()</td><td>返回算术平方根</td></tr><tr><td>log(x)</td><td>返回lnx</td></tr><tr><td>sin(),cos(),tan()</td><td>三角函数</td></tr><tr><td>asin(),acos(),atan()</td><td>反三角函数</td></tr><tr><td>round()</td><td>四舍五入，返回值需进行取整</td></tr></tbody></table><h2 id="选择结构">选择结构</h2><h3 id="if语句">if语句</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(条件A)&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(条件B)&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="switch语句">switch语句</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(表达式)&#123;</span><br><span class="line">    <span class="keyword">case</span> 常数<span class="number">1</span>:</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> 常数<span class="number">2</span>:</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="循环结构">循环结构</h2><h3 id="while语句">while语句</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(条件A)&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;<span class="keyword">while</span>(条件A);</span><br></pre></td></tr></table></figure><p>个人感觉do while没啥用，你要先执行一遍可以在while语句前写吧</p><h3 id="for语句">for语句</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(A;B;C)&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>A是循环变量赋初值</p><p>B是循环条件</p><p>C是循环变量改变</p><p>如果有确定的循环次数就用for，其他用while</p><h3 id="break和continue">break和continue</h3><p>break退出当前循环</p><p>continue退出本轮循环进入下一轮</p><h2 id="数组">数组</h2><p><code>数据类型 数组名[数组大小]=&#123;初值&#125;;</code></p><p>注意下标是从<strong>0</strong>开始</p><h3 id="冒泡排序">冒泡排序</h3><p>相邻两两比较，每轮将最值移动到最左或者右</p><p>高中已经学过，这里不作过多讲解</p><h3 id="二维数组">二维数组</h3><p><code>数据类型 数组名[第一维大小][第二维大小]</code></p><h3 id="memset">memset</h3><p>这个函数用于将数组中的每一个元素赋以相同的值</p><p><code>memset(数组名,值,sizeof(数组名));</code></p><h3 id="字符数组">字符数组</h3><h4 id="初始化">初始化</h4><p>方法1：和普通数组一样</p><p>方法2：</p><p><code>char str[数组大小]=字符串;</code></p><h4 id="输入输出">输入输出</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> str[<span class="number">10</span>];</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,str);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>,str);</span><br></pre></td></tr></table></figure><p>getchar()和putchar()和之前相同</p><p>gets()和puts()用于输入或输出一行字符串（输入要换行结尾，输出自带换行）</p><h4 id="存放方式">存放方式</h4><p>字符数组末尾自带一个空字符串\0，占用一个字符位，所以创建字符数组的时候至少要多一位</p><p>使用getchar()输入时一定要在末尾输出空字符串</p><h3 id="string-h头文件">string.h头文件</h3><h4 id="strlen">strlen()</h4><p>返回字符串长度</p><h4 id="strcmp-A-B">strcmp(A,B)</h4><p>返回A和B字符串大小比较结果，如果A&lt;B则返回一个负整数，如果A=B则返回0，如果A&gt;B则返回一个正整数</p><h4 id="strcpy-A-B">strcpy(A,B)</h4><p>把字符串B复制给A（包括结尾的\0）</p><h4 id="strcat-A-B">strcat(A,B)</h4><p>把字符串B接到字符串A后面</p><h3 id="sscanf和sprintf">sscanf和sprintf</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ssanf(str,<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line"><span class="built_in">sprintf</span>(str,<span class="string">&quot;%d&quot;</span>,n);</span><br></pre></td></tr></table></figure><p>上述代码，sscanf将str用%d的形式写入n中，sprintf将n用%d的形式写入str中</p><p>这里的%d还可以换成别的形式</p><h2 id="函数">函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">返回类型 函数名(参数类型 参数)&#123;</span><br><span class="line">    函数主体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>返回类型中写void意思是空，即该函数没有返回值</p><p>参数也可以不写，如</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello!\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>常规函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">judge</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&gt;<span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(x==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="全局变量">全局变量</h3><p>定义在所有函数之前的变量</p><p>后面的函数都可以改变该变量，也可以使用</p><h3 id="局部变量">局部变量</h3><p>定义在函数内部的变量</p><p>只在函数内部生效，函数结束时变量销毁</p><p>定义函数时的参数为形参，调用函数时的参数才是实参</p><p>所以main()其实也是一个函数，而且返回值为0</p><h3 id="以数组为参数">以数组为参数</h3><p>数组为参数时，和普通局部变量不同，在函数中修改数组就是对原数组的修改</p><p>且数组不能作为返回类型</p><h3 id="嵌套调用">嵌套调用</h3><p>即在一个函数中调用另一个函数</p><h3 id="递归">递归</h3><p>即函数调用自己</p><h2 id="指针">指针</h2><p>指针就是变量的地址</p><p>之前scanf函数里面的&amp;符号就是用来显示变量地址的</p><h3 id="指针变量">指针变量</h3><p>定义时需要加上*</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>* p;</span><br><span class="line"><span class="keyword">double</span>* p;</span><br><span class="line"><span class="keyword">char</span>* p;</span><br></pre></td></tr></table></figure><p>定义多个变量时，*只对第一个变量生效，若需要定义多个指针，则需在变量前都加上</p><p><code>int*p1,*p2,*p3;</code></p><p>p保存的是地址，*p保存的就是该地址的元素</p><p>可以对*p直接赋值</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">int</span> *p=&amp;a;</span><br><span class="line">*p=<span class="number">233</span></span><br></pre></td></tr></table></figure><p>这样赋值之后a的值也会变成233</p><h3 id="指针和数组">指针和数组</h3><p>对数组a[10]而言，a代表的就是a[0]的地址，即a=&amp;a[0]，同理可以推出a+i=&amp;a[i]，*(a+i)=a[i]</p><p>所以输入数组也可以用下面的代码</p><p><code>scanf(&quot;%d&quot;,a+i);</code></p><p>同理，输出也可以用下面的代码</p><p><code>printf(&quot;%d&quot;,*(a+i));</code></p><p>指针和数组是有共同之处的，可以把数组看成特殊的指针</p><p>**注意：**以int类型的指针和数组为例，相邻数组地址相差是4（因为int占用4个字节），但对指针而言，+1就相当于+4（因为是int类型的指针）</p><h3 id="使用指针作为函数参数">使用指针作为函数参数</h3><p>当函数参数为指针类型时，视为将变量的地址传入函数，在函数中改变该地址的值，原先的数据也会改变</p><p>也可以利用指针交换两个数</p><p>这是传统的交换</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a=<span class="number">1</span>,b=<span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> temp=a;</span><br><span class="line">a=b;</span><br><span class="line">b=temp;</span><br></pre></td></tr></table></figure><p>这是用指针交换</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>* a,<span class="keyword">int</span>* b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = *a;</span><br><span class="line">    *a=*b;</span><br><span class="line">    *b =temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于函数中的是形参，所以传统方法在函数中是无法使用的，这时就要用到指针，直接去修改对应地址的元素实现交换</p><h3 id="引用">引用</h3><p>由于函数中只能该改编形参，要想改变全局变量就只能用指针，通过引用也可以改变全局变量</p><p>语法是在函数的参数前加上&amp;，如</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">chang</span><span class="params">(<span class="keyword">int</span>&amp;x)</span></span>&#123;</span><br><span class="line">    x=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样引用该函数时就能将传入的函数改成1</p><h4 id="引用指针">引用指针</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>*&amp;p1,<span class="keyword">int</span>*&amp;p2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>*temp=p1;</span><br><span class="line">    p1=p2;</span><br><span class="line">    p2=temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数通过引用指针来改变原指针，达到交换值的效果</p><h2 id="结构体">结构体</h2><p>把一些相关的变量放在一起存储</p><h3 id="定义">定义</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Name</span> &#123;</span></span><br><span class="line">    基本数据结构或自定义的数据类型</span><br><span class="line">&#125;；</span><br></pre></td></tr></table></figure><p>比如</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">char</span> gender;</span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">20</span>];</span><br><span class="line">    <span class="keyword">char</span> major[<span class="number">20</span>];</span><br><span class="line">&#125;Alice,Bob,stu[<span class="number">1000</span>];</span><br></pre></td></tr></table></figure><p>Alice和Bob是两个结构体变量，stu[1000]是结构体数组</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">studentAlice;</span><br><span class="line">studentstu[<span class="number">1000</span>];</span><br></pre></td></tr></table></figure><p>这样定义也是可以的</p><h3 id="访问">访问</h3><p><code>Alice.id</code></p><p><code>Bob.name</code></p><p>这是最常用的，而当结构体里面有指针时</p><p>原先的<code>(*p).id</code>可以改成<code>p-&gt;id</code></p><h3 id="初始化-2">初始化</h3><p><code>stu.id=1;</code></p><p>或者</p><p><code>scanf(&quot;%d&quot;,&amp;stu.id);</code></p><p>但这样不太方便</p><p>结构体默认会生成一个与结构体同名的构造函数student(){}</p><p>可以自定义构造函数，如</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">studentInfo</span>(<span class="keyword">int</span> _id, <span class="keyword">char</span> _gender)&#123;</span><br><span class="line">  id=_id;</span><br><span class="line">  gender=_gender;</span><br><span class="line">&#125;</span><br><span class="line">studentInfostu=<span class="built_in">studentInfo</span>(<span class="number">10086</span>,<span class="string">&#x27;M&#x27;</span>);<span class="comment">//调用构造函数进行赋值</span></span><br></pre></td></tr></table></figure><p>构造函数可以定义多个，用于不同场合，<strong>如果自定义了构造函数，就不能不经初始化就定义结构体变量</strong>，所以在自定义构造函数之前加上<code>studentInfo()&#123;&#125;</code>就可以不初始化定义变量了。</p><h2 id="补充">补充</h2><h3 id="cin和count">cin和count</h3><p>在c++中，输入和输出函数为cin和cout，需要添加头文件（不过这两个速度没有scanf和printf快）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br></pre></td></tr></table></figure><h4 id="cin">cin</h4><p>cin的输入不指定格式，直接写变量名就可以了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cin&gt;&gt;n;</span><br><span class="line">cin&gt;&gt;db;</span><br><span class="line">cin&gt;&gt;c;</span><br><span class="line">cin&gt;&gt;n&gt;&gt;db&gt;&gt;c;</span><br></pre></td></tr></table></figure><p>如果想要读入一整行，需要使用getling函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> str[<span class="number">100</span>];</span><br><span class="line">cin.<span class="built_in">getline</span>(str,<span class="number">100</span>);</span><br><span class="line"><span class="comment">//如果是string</span></span><br><span class="line">string str;</span><br><span class="line"><span class="built_in">getline</span>(cin,str);</span><br></pre></td></tr></table></figure><h4 id="cout">cout</h4><p>cout使用和cin类似</p><p><code>cout&lt;&lt;n&lt;&lt;db&lt;&lt;c&lt;&lt;str;</code></p><p>这样输出中间是没有空格的，如果需要的话要自己加上&quot; &quot;</p><p>同理，如果需要换行的话也要自己加上&quot;\n”，可以用endl代替\n</p><h3 id="浮点数的比较">浮点数的比较</h3><p>由于浮点数的不确定性，需要用极小数来比较</p><p>通常定义一个eps</p><p><code>const double eps = 1e-8;</code></p><p>如果两数之差小于这个值，就认为他们相等</p><p><code>#define Equ(a,b) ((fabs((a)-(b)))&lt;(eps))  </code></p><p>同理，大于即两数差大于该值，小于即两数差小于-eps</p><p>两数差大于-eps即大于等于</p><p>两数差小于eps即小于等于</p><h4 id="圆周率">圆周率</h4><p><code>const double Pi=acos(-1.0);</code></p><h3 id="复杂度">复杂度</h3><h4 id="时间复杂度">时间复杂度</h4><p>即执行运算的次数等级，此处等级可理解为无穷大的级数，如2n次和n次是同一级</p><h4 id="空间复杂度">空间复杂度</h4><p>即算法要消耗的最大空间</p><p>一般情况下空间都是够用的，所以可以牺牲空间来换取时间</p><h4 id="编码复杂度">编码复杂度</h4><p>算法思想的深度</p><h3 id="黑盒测试">黑盒测试</h3><h4 id="单点测试">单点测试</h4><p>即程序只需要执行一组数据即可</p><h4 id="多点测试">多点测试</h4><p>要求程序能一次运行所有数据，并且运行结果都需要正确才能通过测试</p><p>1.while…EOF</p><p>读到文件末尾为止</p><p>2.while…break</p><p>满足某个条件时停止输入</p><p>3.while(T–)</p><p>给出测试数据的组数</p><hr><p>第二章知识点就是这些，虽然照着书上依葫芦画瓢写了一遍但感觉离真正理解还是有一段距离，尤其是不怎么接触到过的指针、结构体</p><p>上述是我个人的理解总结的，可能会有错误，希望得到指正！</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
